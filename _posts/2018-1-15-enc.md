---
title: 'If you want to keep a secret, you must also hide it from yourself. ğŸ‘½'
background: backgrounds/home.jpg
---

å¦‚æœä½ æƒ³ä¿ä½ä¸€ä¸ªç§˜å¯†, ä½ å¿…é¡»ä»ä½ å¼€å§‹å°±ä¸çŸ¥é“å®ƒ
========================================

cryptor æ¨¡å—æˆå°±äº†æˆ‘ä»¬çš„\*\*\*, éšè—è‡ªå·±. æ”¯æŒå¸¸è§çš„åŠ å¯†ç®—æ³•ä»¥åŠå·²ç»ä¸å¤ªå®‰å…¨çš„åŠ å¯†ç®—æ³•ä¹Ÿè¢«æ”¯æŒ.

TL;DR
------

<!-- add TL;DR -->

å¯¼å…¥(import)
-----------

```python
from __future__ import absolute_import, division, print_function, \
  with_statement

import os
import sys
import hashlib
import logging

from shadowsocks import common
from shadowsocks.crypto import rc4_md5, openssl, mbedtls, sodium, table
```

å¼•å…¥ `os`, `sys`, `hashlib`, `logging` æ¨¡å—

* [os][os-module]
* [sys][sys-module]
* [hashlib][hashlib-module]
* [logging][logging-module]

å¸¸é‡(constants)
--------------

```python
CIPHER_ENC_ENCRYPTION = 1
CIPHER_ENC_DECRYPTION = 0
```

åŠ å¯†æ ‡å¿—ä½ä¸º `1`, è§£å¯†æ ‡å¿—ä½ä¸º `0`, ä¸æ˜¯ SS è§„å®šçš„, Openssl è§„å®šçš„:

>EVP\_CipherInit\_ex(), EVP\_CipherUpdate() and EVP\_CipherFinal\_ex() are functions that can be used for decryption or encryption. The operation performed depends on the value of the enc parameter. It should be set to 1 for encryption, 0 for decryption and -1 to leave the value unchanged (the actual value of 'enc' being supplied in a previous call).

>å¼•ç”¨è‡ª: <https://www.openssl.org/docs/man1.1.0/crypto/EVP_CIPHER_CTX_new.html>

```python
METHOD_INFO_KEY_LEN = 0
METHOD_INFO_IV_LEN = 1
METHOD_INFO_CRYPTO = 2

method_supported = {}
method_supported.update(rc4_md5.ciphers)
method_supported.update(openssl.ciphers)
method_supported.update(mbedtls.ciphers)
method_supported.update(sodium.ciphers)
method_supported.update(table.ciphers)
```

åœ¨æ–‡ä»¶æ¨¡å—å¯¼å…¥é˜¶æ®µ `from shadowsocks.crypto import rc4_md5, openssl, mbedtls, sodium, table` æŠŠæ‰€æœ‰æ”¯æŒçš„æ–¹æ³•å…¨éƒ¨å¯¼å…¥è¿›æ¥.

* METHOD\_INFO\_L\_KEY\_LEN: \_method\_info ç´¢å¼•å€¼, ä»£è¡¨çš„æ˜¯ KEY çš„é•¿åº¦
* METHOD\_INFO\_IV_LEN: \_method\_info ç´¢å¼•å€¼, ä»£è¡¨çš„æ˜¯ IV(åˆå§‹åŒ–å‘é‡) çš„é•¿åº¦
* METHOD\_INFO\_CRYPTO: \_method\_info ç´¢å¼•å€¼, ä»£è¡¨çš„æ˜¯åŠ å¯†çš„å‡½æ•°

çœ‹ä¸€ä¸‹ `rc4_md5` å¯¼å‡ºæ¥çš„å˜é‡:

```python
...
ciphers = {
    'rc4-md5': (16, 16, create_cipher),
}
...
```

å˜é‡æŒ‡å‘:

METHOD\_INFO\_L\_KEY\_LEN => 16

METHOD\_INFO\_IV_LEN => 16

METHOD\_INFO\_CRYPTO => create_cipher

æŠŠæ‰€æœ‰æ”¯æŒçš„åŠ å¯†ç®—æ³•æ”¾åˆ° `method_supported` å˜é‡é‡Œé¢.

è¾…åŠ©å‡½æ•°/å˜é‡
------

### random_string

```python
def random_string(length):
    return os.urandom(length)
```

æ ¹æ® `length` è·å–éšæœºå­—ç¬¦ä¸².

[os.urandom][os-urandom-method]

### cached_keys

```python
cached_keys = {}
```

æ ¹æ® `password` æ‰©å±•æˆé•¿å­—ç¬¦ä¸².

### try_cipher

```python
def try_cipher(key, method=None, crypto_path=None):
    Cryptor(key, method, crypto_path)
```

å°è¯•ç®—æ³•, æ˜¯ä¸ºäº†åœ¨æ£€æŸ¥é…ç½®æ–‡ä»¶çš„æ—¶å€™æ£€æŸ¥åŠ å¯†ç®—å¦æ˜¯å¦è¢«æ”¯æŒ, å¦‚æœä¸è¢«æ”¯æŒä¼šæŠ¥é”™å¯¼è‡´æœåŠ¡æ— æ³•å¯åŠ¨.

### EVP_BytesToKey

```python
def EVP_BytesToKey(password, key_len, iv_len):
    # equivalent to OpenSSL's EVP_BytesToKey() with count 1
    # so that we make the same key and iv as nodejs version
    cached_key = '%s-%d-%d' % (password, key_len, iv_len)
    r = cached_keys.get(cached_key, None)
    if r:
        return r
    m = []
    i = 0
    while len(b''.join(m)) < (key_len + iv_len):
        md5 = hashlib.md5()
        data = password
        if i > 0:
            data = m[i - 1] + password
        md5.update(data)
        m.append(md5.digest())
        i += 1
    ms = b''.join(m)
    key = ms[:key_len]
    iv = ms[key_len:key_len + iv_len]
    cached_keys[cached_key] = (key, iv)
    return key, iv
```

æ ¹æ® password å’Œ key\_len, iv\_len æ¥æ‰©å±• password, ç®—æ³•é‡‡ç”¨çš„æ˜¯[openssl-EVP_BytesToKey][openssl-EVP_BytesToKey]

æ ¹æ®æ³¨é‡Šæ¥çœ‹, æ²¡æœ‰ä½¿ç”¨ openssl å†…ç½®çš„ `EVP_BytesToKey` åŠ å¯†ç®—æ³•æ˜¯ä¸ºäº†å’Œ `nodejs` ç‰ˆæœ¬çš„ `shadowsocks` ä¿æŒä¸€è‡´, ä¸è¿‡ç°åœ¨çš„ nodejs ç‰ˆæœ¬çš„ `shadowsocks` å·²ç»[åœæ­¢ç»´æŠ¤](https://github.com/shadowsocks/shadowsocks-nodejs)äº†.

`cached_key = '%s-%d-%d' % (password, key_len, iv_len)` ç”Ÿæˆç¼“å­˜çš„key, åŒæ ·çš„ password ç”ŸæˆåŒæ ·çš„ (key, iv), æ‰€ä»¥å¯ä»¥åšç¼“å­˜.

åŠ å¯†ç±» Crypto
------------

```python
class Crypto(object):
    ...
```

å„ç±»åŠ å¯†ç®—æ³•çš„ wrapper, ä¼ é€’åŠ å¯†ç®—æ³•å, ç„¶åè°ƒç”¨å…¶å¯¹ç”¨çš„åŠ å¯†æ–¹æ³•è¿›è¡ŒåŠ å¯†.

### \_\_init\_\_

```python
def __init__(self, password, method, crypto_path=None):
    """
    Crypto wrapper
    :param password: str cipher password
    :param method: str cipher
    :param crypto_path: dict or none
        {'openssl': path, 'sodium': path, 'mbedtls': path}
    """
    self.password = password
    self.key = None
    self.method = method
    self.iv_sent = False # åŠ å¯†å‘é‡éœ€è¦åŒæ–¹å…±äº«, æ˜¯å¦è¢«å‘é€çš„æ ‡å¿—ä½
    self.cipher_iv = b''
    self.decipher = None # è§£å¯†
    self.decipher_iv = None # è§£å¯†å‘é‡
    self.crypto_path = crypto_path
    method = method.lower()
    self._method_info = Cryptor.get_method_info(method)
    if self._method_info:
        self.cipher = self.get_cipher(
            password, method, CIPHER_ENC_ENCRYPTION,
            random_string(self._method_info[METHOD_INFO_IV_LEN])
        )
    else:
        logging.error('method %s not supported' % method)
        sys.exit(1)
```

å‚æ•°:

1. self: å®ä¾‹
1. password åŠ å¯†ç§˜é’¥, å°±æ˜¯é…ç½®æ–‡ä»¶(json æ ¼å¼)é‡Œé¢çš„ password å­—æ®µ
1. method åŠ å¯†ç®—æ³•å, å°±æ˜¯é…ç½®æ–‡ä»¶ä¸­çš„ method å­—æ®µ
1. crypto_path è‡ªå®šä¹‰åŠ å¯†åº“çš„è·¯å¾„, å¦‚æœä¸ºé…ç½®, å°†ä»ç³»ç»Ÿè·¯å¾„ä¸­å»æ‰¾

`cipher_iv` ä¸ºåˆå§‹å‘é‡, è§[ç»´åŸºç™¾ç§‘è§£é‡Š](https://zh.wikipedia.org/wiki/%E5%88%9D%E5%A7%8B%E5%90%91%E9%87%8F)([è‹±æ–‡ç‰ˆæœ¬](https://en.wikipedia.org/wiki/Initialization_vector))


```shell
                       |-------------> password ç”¨æˆ·åŠ å¯†ç§˜é’¥
                       |-------------> key ç”Ÿæˆçš„åŠ å¯†ç§˜é’¥
instance(å®ä¾‹) ---------|------------> method åŠ å¯†ç®—æ³•
                       |-------------> iv_sent åˆå§‹åŒ–å‘é‡æ˜¯å¦å·²ç»è¢«å‘é€
                       |-------------> cipher_iv åˆå§‹åŒ–å‘é‡
                       |-------------> decipher è§£å¯†
                       |-------------> decipher_iv è§£å¯†çš„åˆå§‹åŒ–å‘é‡
                       |-------------> cryptor_path åŠ å¯†åº“çš„åœ°å€
                       |-------------> _method_info æ ¹æ® method è·å¾—çš„å…³äºè¯¥åŠ å¯†ç®—æ³•çš„ä¿¡æ¯
                       |-------------> cipher method åŠ å¯†ç±»å®ä¾‹

```

`if self._method_info:` å¦‚æœå…³äºæŒ‡å®šçš„è¯¥åŠ å¯†ç®—æ³•ä¸æ”¯æŒ, `sys.exit(1)` æŠ›å‡ºé”™è¯¯å·²ç»ä¸èƒ½è§£å†³é—®é¢˜äº†, ç›´æ¥é€€å‡ºè¿›ç¨‹.

### get\_method\_info

```python
@staticmethod
def get_method_info(method):
    method = method.lower()
    m = method_supported.get(method)
    return m

```

`@staticmethod` è£…é¥°å™¨è®©è¯¥æ–¹æ³•æˆä¸ºç±»çš„é™æ€æ–¹æ³•

å‚æ•°:

1. method: æ ¹æ®åŠ å¯†ç®—æ³•åè·å–å…³äºè¯¥åŠ å¯†ç®—æ³•çš„ä¿¡æ¯
1. @return (ken\_len, iv\_len, åˆ›å»ºè¯¥åŠ å¯†ç®—æ³•çš„æ–¹æ³•)

### iv\_len

```python
def iv_len(self):
    return len(self.cipher_iv)
```

è·å–å®ä¾‹çš„åŠ å¯†å‘é‡(cipher_iv)çš„é•¿åº¦

### get\_cipher

```python
def get_cipher(self, password, method, op, iv):
    password = common.to_bytes(password)
    m = self._method_info
    if m[METHOD_INFO_KEY_LEN] > 0:
        key, _ = EVP_BytesToKey(password,
                                m[METHOD_INFO_KEY_LEN],
                                m[METHOD_INFO_IV_LEN])
    else:
        # key_length == 0 indicates we should use the key directly
        key, iv = password, b''
    self.key = key
    iv = iv[:m[METHOD_INFO_IV_LEN]]
    if op == CIPHER_ENC_ENCRYPTION:
        # this iv is for cipher not decipher
        self.cipher_iv = iv
    return m[METHOD_INFO_CRYPTO](method, key, iv, op, self.crypto_path)
```

å‚æ•°:

1. self: å®ä¾‹æœ¬èº«
1. password: åŠ å¯†ç§˜é’¥
1. method: åŠ å¯†ç®—æ³•
1. op: æ“ä½œ(æ˜¯åŠ å¯†(CIPHER\_ENC\_ENCRYPTION)è¿˜æ˜¯è§£å¯†(CIPHER\_ENC\_DECRYPTION))
1. iv: è°ƒç”¨ `random_string` ç”Ÿæˆçš„éšæœºå­—ç¬¦ä¸²

`if m[METHOD_INFO_KEY_LEN] > 0:` å¦‚æœè¯¥åŠ å¯†ç®—æ³•éœ€è¦çš„åŠ å¯†ç§˜é’¥é•¿åº¦å¤§äºé›¶, è¯´æ˜éœ€è¦æ ¹æ® `password` æ‰©å±•å‡ºæ¥ (key, iv), `key, _ = EVP_BytesToKey(password, m[METHOD_INFO_KEY_LEN], m[METHOD_INFO_IV_LEN])` è°ƒç”¨ `EVP_BytesToKey` æ‰©å±• `password`.

`else:` æŒ‡ç¤ºåº”è¯¥ç›´æ¥ä½¿ç”¨ password

`self.key = key` å°† key å­˜å‚¨åœ¨ self ä¸Š

`iv = iv[:m[METHOD_INFO_IV_LEN]]` å–å‡ºè¯¥åŠ å¯†ç®—æ³•éœ€è¦çš„å‘é‡é•¿åº¦

`if op == CIPHER_ENC_ENCRYPTION:` å¦‚æœæ˜¯åŠ å¯†è¿‡ç¨‹, `self.cipher_iv = iv` å°†è¯¥å‘é‡å­˜å‚¨åœ¨ self ä¸Š

`return m[METHOD_INFO_CRYPTO](method, key, iv, op, self.crypto_path)` å–å‡º m ä¸­çš„åŠ å¯†å‡½æ•°ç±»ç„¶åä¼ å…¥å‚æ•°åˆ›å»ºåŠ å¯†å®ä¾‹, ç­‰åˆ°åé¢è¯»åŠ å¯†æ¨¡å—çš„ä»£ç ä¼šæåˆ°è¿™é‡Œ.

### encrypt

```python
def encrypt(self, buf):
    if len(buf) == 0:
        return buf
    if self.iv_sent:
        return self.cipher.encrypt(buf)
    else:
        self.iv_sent = True
        return self.cipher_iv + self.cipher.encrypt(buf)
```

å‚æ•°:

1. self: å®ä¾‹æœ¬èº«
1. buf: éœ€è¦åŠ å¯†çš„æ•°æ®

`if len(buf) == 0:` å¦‚æœ `buf` ä¸ºç©º, å°±ä¸ç”¨åŠ å¯†äº†, ä»€ä¹ˆä¹Ÿæ²¡æœ‰å°±æ˜¯æœ€å¥½çš„åŠ å¯†æ–¹å¼

`if self.iv_sent:` å¦‚æœ iv å‘é‡å·²ç»è¢«å‘é€äº†, ç›´æ¥æŠŠæ•°æ®åŠ å¯†, ç„¶åå‘é€å°±å¥½

`else:` å¦‚æœ iv å‘é‡æ²¡æœ‰è¢«å‘é€, æ‹¼æ¥åœ¨æœ‰æ•ˆè´Ÿè½½æ•°æ®çš„å‰ç«¯, åé¢æ‹¼æ¥ä¸ŠåŠ å¯†çš„æ•°æ®, åœ¨è¿™é‡Œä¼šæ ‡è¯† iv å‘é‡å·²ç»è¢«å‘é€(åé¢ä¼šè§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ iv_sent å˜é‡).

### decrypt

```python
def decrypt(self, buf):
    if len(buf) == 0:
        return buf
    if self.decipher is None:
        decipher_iv_len = self._method_info[METHOD_INFO_IV_LEN]
        decipher_iv = buf[:decipher_iv_len]
        self.decipher_iv = decipher_iv
        self.decipher = self.get_cipher(
            self.password, self.method,
            CIPHER_ENC_DECRYPTION,
            decipher_iv
        )
        buf = buf[decipher_iv_len:]
        if len(buf) == 0:
            return buf
    return self.decipher.decrypt(buf)
```

å‚æ•°:

1. self: å®ä¾‹æœ¬èº«
1. buf: åŠ å¯†çš„æ•°æ®(å®Œå…¨ä¸å¯è¯»)

`if len(buf) == 0:` å¦‚æœä»€ä¹ˆéƒ½æ²¡æœ‰, ä¸å¿…è¦è§£å¯†

`if self.decipher is None:` å¦‚æœ `self.decipher` ä¸º None, è¯´æ˜æ˜¯ç¬¬ä¸€æ¬¡è§£å¯†å…³äºè¯¥æ¬¡è¿æ¥çš„æ•°æ®, éœ€è¦åˆ›å»ºè§£å¯†çš„ç±»å®ä¾‹

`decipher_iv_len = self._method_info[METHOD_INFO_IV_LEN]` å–å‡ºè¯¥åŠ å¯†ç®—æ³•çš„åˆå§‹åŒ–å‘é‡(iv)çš„é•¿åº¦

`decipher_iv = buf[:decipher_iv_len]` ä»åŠ å¯†çš„æ•°æ®ä¸­å–å‡ºæ¥è§£å¯†å‘é‡

`self.decipher_iv = decipher_iv` å°†è§£å¯†å‘é‡å­˜å‚¨åœ¨ self ä¸Š

`self.decipher = self.get_cipher( self.password, self.method, CIPHER_ENC_DECRYPTION, decipher_iv)` è·å–è§£å¯†ç±»å®ä¾‹, ä¼ å…¥çš„æ˜¯ `CIPHER_ENC_DECRYPTION` è§£å¯†æ ‡å¿—ä½å¸¸é‡

`buf = buf[decipher_iv_len:]` ä» buf ä¸­åˆ é™¤åˆå§‹åŒ–å‘é‡(iv), å› ä¸ºåˆå§‹åŒ–å‘é‡åªæ˜¯ç”¨æ¥è§£å¯†æ•°æ®, å¹¶ä¸æ˜¯æ•°æ®çš„ä¸€éƒ¨åˆ†

`if len(buf) == 0:` å¦‚æœåˆ é™¤ä¹‹åæ²¡æœ‰äº†å…¶ä»–æ•°æ®, è¯´æ˜æ²¡æœ‰ä»»ä½•æ•°æ®, ssclient åªæ˜¯ä¼ é€’äº†åˆå§‹åŒ–å‘é‡, `return buf` ç›´æ¥è¿”å›åˆ é™¤äº†å‡ºäº‹é»„ä¸¤é¡¹çš„ buf

`return self.decipher.decrypt(buf)` è°ƒç”¨ `decipher` çš„ `decrypt` è§£å¯†è¢«åŠ å¯†çš„æ•°æ®

<!-- TODO: -->

<!-- Generate by template.js -->
<div class="program-flow-walkthrough" data-panel-title="ç¨‹åºæµæ§åˆ¶é¢æ¿" id="crypto-class">
			<div class="program-flow-walkthrough-codesource">
				<div class="line-highlight"></div>
				<div class="codehilite">
					{% highlight python %}
class Cryptor(object):
    def __init__(self, password, method, crypto_path=None):
        """
        Crypto wrapper
        :param password: str cipher password
        :param method: str cipher
        :param crypto_path: dict or none
            {'openssl': path, 'sodium': path, 'mbedtls': path}
        """
        self.password = password
        self.key = None
        self.method = method
        self.iv_sent = False
        self.cipher_iv = b''
        self.decipher = None
        self.decipher_iv = None
        self.crypto_path = crypto_path
        method = method.lower()
        self._method_info = Cryptor.get_method_info(method)
        if self._method_info:
            self.cipher = self.get_cipher(
                password, method, CIPHER_ENC_ENCRYPTION,
                random_string(self._method_info[METHOD_INFO_IV_LEN])
            )
        else:
            logging.error('method %s not supported' % method)
            sys.exit(1)
					{% endhighlight %}
				</div>
			</div>
			<table>
				<tr class="task-queue">
								<th>Task</th>
								<td><div class="event-loop-items">
									<div class="event-loop-rail">
										<div class="event-loop-item">Run script</div><div class="event-loop-item">setTimeout callback</div>
									</div>
								</div></td>
							</tr>
<tr class="microtask-queue">
								<th>Microtasks</th>
								<td><div class="event-loop-items">
									<div class="event-loop-rail">
										<div class="event-loop-item">Run script</div><div class="event-loop-item">setTimeout callback</div>
									</div>
								</div></td>
							</tr>
<tr class="js-stack">
								<th>JS Stack</th>
								<td><div class="event-loop-items">
									<div class="event-loop-rail">
										<div class="event-loop-item">Run script</div><div class="event-loop-item">setTimeout callback</div>
									</div>
								</div></td>
							</tr>
<tr class="event-loop-log">
								<th>Log</th>
								<td><div class="event-loop-items">
									<div class="event-loop-rail">
										<div class="event-loop-item">Run, script</div><div class="event-loop-item">setTimeout callback</div>
									</div>
								</div></td>
							</tr>
			</table>
			<div class="event-loop-controls">
					    <svg viewBox="0 0 5 2">
					      <path d="M2,0 L2,2 L0,1 z"></path>
					      <path d="M3,0 L5,1 L3,2 z"></path>
					      <path class="prev-btn" d="M0,0 H2.5V2H0z"></path>
					      <path class="next-btn" d="M2.5,0 H5V2H2.5z"></path>
					    </svg>
					</div>
			<div class="event-loop-commentary">
					    <div class="event-loop-commentary-item"></div>
					</div>
		</div>
<!-- Generate by template.js END -->

{% include eventloopanimation.html %}
<script>
/* Transformed by babel-transform.js */
'use strict';

;(function () {
  var cryptoClass = document.getElementById('crypto-class');
  var cryptoClassEventLoop = new EventLoopAnimation(cryptoClass);
  cryptoClassEventLoop.state().moveToLine(3).showCodeBar().state().moveToLine(4).state().moveToLine(5).state().moveToLine(6).state().moveToLine(7).state().moveToLine(8);
})();
/* Transformed by babel-transform.js END */
</script>


[os-module]: <https://docs.python.org/2.7/library/os.html>
[sys-module]: <https://docs.python.org/2.7/library/sys.html>
[hashlib-module]: <https://docs.python.org/2.7/library/hashlib.html>
[logging-module]: <https://docs.python.org/2.7/library/logging.html>
[os-urandom-method]: <https://docs.python.org/2.7/library/os.html#os.urandom>
[openssl-EVP_BytesToKey]: <https://wiki.openssl.org/index.php/Manual:EVP_BytesToKey(3)>

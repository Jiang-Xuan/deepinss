---
title: tcprelay ğŸ’Œ
---
Introduce to TCPRelay
=====================

EventLoop äº‹ä»¶å‘ç”Ÿäº†, éœ€è¦å¤„ç†å™¨è¿›è¡Œå¤„ç†, åœ¨è¿™é‡Œå¤„ç† TCP çš„æµç¨‹. åœ¨ `local.py` é‡Œé¢æœ‰è¿™ä¹ˆä¸€è¡Œä»£ç  `tcp_server = tcprelay.TCPRelay(config, dns_resolver, True)`, åˆ›å»º TCP çš„æœåŠ¡å™¨. è¿˜æœ‰è¿™ä¹ˆä¸€è¡Œ `tcp_server.add_to_loop(loop)`, å°†å…¶æ·»åŠ è¿›å…¥äº‹ä»¶è½®è®­å™¨, å‘ç”Ÿäº‹ä»¶çš„æ—¶å€™, è°ƒç”¨è¿™é‡Œçš„æ–¹æ³•æ¥å¤„ç† TCP è¯·æ±‚.

TL;DR
------

<!-- TODO: add TL;DR -->

æœ¯è¯­è§„å®š
-------

* æµè§ˆå™¨: socks5 çš„å®¢æˆ·ç«¯
* local: Shadowsocks çš„ local ç«¯
* server: Shadowsocks çš„ server ç«¯
* æœåŠ¡å™¨: è¯·æ±‚çš„æœåŠ¡ç«¯(e.g. google.comæœåŠ¡)
* local socket: ä»£è¡¨ local ç«¯åˆ›å»ºçš„ç”¨æ¥å’Œ æµè§ˆå™¨ é€šè®¯çš„ socket
* remote socket: ä»£è¡¨ local ç«¯åˆ›å»ºçš„ç”¨æ¥å’Œ server é€šè®¯çš„ socket

Notes: **è®°ä½, æˆ‘ä»¬è®¨è®ºçš„æ˜¯ local ç«¯çš„ä»£ç , æ‰€ä»¥æˆ‘ä»¬çš„æ•°æ®æ˜¯è¿™æ ·æµåŠ¨çš„**, ä¸æ¶‰åŠ æœåŠ¡å™¨.

```shell
            |--------------->|                   |------------>|                 |\
æµè§ˆå™¨ ------|                |---- local ç«¯ ------|            | ---- server ç«¯---|\ è¿™è¾¹å’ŒæœåŠ¡å™¨é€šè®¯
            |<---------------|                   |<------------|                 |\
```

å¯¼å…¥æ¨¡å—
-------

```python
from __future__ import absolute_import, division, print_function, \
    with_statement

import time
import socket
import errno
import struct
import logging
import traceback
import random

from shadowsocks import cryptor, eventloop, shell, common
from shadowsocks.common import parse_header, onetimeauth_verify, \
    onetimeauth_gen, ONETIMEAUTH_BYTES, ONETIMEAUTH_CHUNK_BYTES, \
    ONETIMEAUTH_CHUNK_DATA_LEN, ADDRTYPE_AUTH
```

å¼•å…¥å†…ç½®æ¨¡å—, è¿™é‡Œå°¤å…¶è¦æ³¨æ„ `struct` æ¨¡å—, åˆæ˜¯å’Œ C æ‰“äº¤é“çš„ ğŸ‘€ æ¨¡å—. ä» `shadowsocks` æ¨¡å—å¼•å…¥ `crypto` åŠ å¯†æ¨¡å—, å¯¼å…¥ `eventloop` æ¨¡å—, ä¸»è¦æ˜¯ç”¨åˆ°é‡Œé¢çš„ä¸€äº›å¸¸é‡(POLL\_IN, POLL\_OUT, etc.)

æ¨¡å—å¸¸é‡å®šä¹‰
----------

```python
# we clear at most TIMEOUTS_CLEAN_SIZE timeouts each time
TIMEOUTS_CLEAN_SIZE = 512
```

ä¸€æ¬¡æœ€å¤šæ¸…é™¤çš„è¿‡æœŸ socket çš„æ•°é‡, å¦‚æœè¶…æ—¶çš„ socket è¶…è¿‡äº†è¿™ä¸ªä¸´ç•Œç‚¹, åˆ™åªå¤„ç† 512 ä¸ª, å‰©ä½™ç­‰å¾…ä¸‹æ¬¡å¤„ç†, ä¸»è¦æ˜¯ä¸ºäº†èƒ½åŠæ—¶å¤„ç†å‘ç”Ÿçš„äº‹ä»¶, ä¸è‡³äºåœ¨è¶…æ—¶è¯·æ±‚è¿‡å¤šçš„æ—¶å€™å¯¼è‡´åç»­äº‹ä»¶çš„å¤„ç†è¢«å»¶è¿Ÿ.

```python
MSG_FASTOPEN = 0x20000000
```

<!-- TODO: æš‚æ—¶ä¸çŸ¥è¯¥å¸¸é‡çš„ä½œç”¨ -->

```python
# SOCKS METHOD definition
METHOD_NOAUTH = 0

# SOCKS command definition # è¿™é‡Œçš„å˜é‡æ˜¯ç”± socks åè®®è§„å®šçš„åè®®å¤´çš„å¸¸é‡
CMD_CONNECT = 1
CMD_BIND = 2
CMD_UDP_ASSOCIATE = 3
```

SOCKS5 åè®®è§„å®šçš„è®¤è¯æ–¹æ³•å’Œè¿æ¥è¡Œä¸ºçš„å¸¸é‡å€¼, å¯ä»¥çœ‹çœ‹ [Wikipedia-socks5][Wikipedia-socks5-zh] å…³äº SOCKS5 æ¡æ‰‹åè®®çš„è¯¦ç»†ä»‹ç».

[è‹±æ–‡ç‰ˆä»‹ç»][Wikipedia-socks5-en], ä¸­æ–‡ç‰ˆçš„ Wikipedia æ­£å¸¸æ˜¯æ— æ³•è®¿é—®çš„.

```python
# for each opening port, we have a TCP Relay

# for each connection, we have a TCP Relay Handler to handle the connection

# for each handler, we have 2 sockets:
#    local:   connected to the client
#    remote:  connected to remote server

# for each handler, it could be at one of several stages:

# as sslocal:
# stage 0 auth METHOD received from local, reply with selection message
# stage 1 addr received from local, query DNS for remote
# stage 2 UDP assoc
# stage 3 DNS resolved, connect to remote
# stage 4 still connecting, more data from local received
# stage 5 remote connected, piping local and remote

# as ssserver:
# stage 0 just jump to stage 1
# stage 1 addr received from local, query DNS for remote
# stage 3 DNS resolved, connect to remote
# stage 4 still connecting, more data from local received
# stage 5 remote connected, piping local and remote

STAGE_INIT = 0
STAGE_ADDR = 1
STAGE_UDP_ASSOC = 2
STAGE_DNS = 3
STAGE_CONNECTING = 4
STAGE_STREAM = 5
STAGE_DESTROYED = -1
```

å¯¹äºæ¯ä¸€ä¸ªç›‘å¬çš„ç«¯å£, éƒ½ä¼šæœ‰ä¸€ä¸ª TCPrelay, å¯¹äºæ¯ä¸€æ¬¡è¿æ¥, éƒ½æœ‰ TCPRelayHandler æ¥å¤„ç†è¿™ä¸ªè¯·æ±‚.

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, æˆ‘ä»¬æœ‰ä¸¤ä¸ª socket:

1. local: è¿æ¥ client ç«¯
1. remote: è¿æ¥ server æœåŠ¡å™¨

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, å®ƒå¿…é¡»å¤„åœ¨è¿™äº›çŠ¶æ€ä¹‹ä¸€(è¿™å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœº, å¦‚æœä½ è¯»è¿‡ TCP çš„åŸç†, ä¼šå‘ç° TCP è¿æ¥ä¹Ÿæ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„çŠ¶æ€æœº, æœ‰å…´è¶£å¯ä»¥çœ‹ä¸‹IBMçš„å®˜æ–¹æ–‡æ¡£, éå¸¸æ£’, åœ¨[è¿™é‡Œ][TCPçŠ¶æ€æœº]):

sslocal çŠ¶æ€:

1. stage 0 æ”¶åˆ° æµè§ˆå™¨ å‘è¿‡æ¥çš„è®¤è¯ METHOD, ç„¶åå›å¤ç»™ æµè§ˆå™¨ é€‰æ‹©çš„ä¿¡æ¯
1. stage 1 æ”¶åˆ° local å‘è¿‡æ¥çš„ addr(è¯·æ±‚åœ°å€), å¼€å§‹æŸ¥è¯¢ server(ä¹Ÿå°±æ˜¯è¯´åœ¨é…ç½®æ–‡ä»¶é‡Œé¢ä½ å¯ä»¥å¡«å†™ssserverçš„åŸŸå, è€Œä¸ä»…ä»…å¡«å†™ IP åœ°å€) çš„ DNSä¿¡æ¯
1. stage 3 DNS æŸ¥è¯¢æˆåŠŸ, å¼€å§‹è¿æ¥ server
1. stage 4 ä»åœ¨å’Œ server è¿æ¥ä¸­, å¯ä»¥ä» æµè§ˆå™¨ è·å–æ›´å¤šä¿¡æ¯äº†, ç­‰ server ä¸€æ—¦è¿æ¥æˆåŠŸ, å°±å°†è¿™äº›æ•°æ®ä¸€èµ·å‘ç»™ server
1. stage 5 server è¿æ¥å»ºç«‹æˆåŠŸ, piping æµè§ˆå™¨ å’Œ server

`STAGE_DESTORED` è¯´æ˜è¯·æ±‚å·²ç»è¢«é”€æ¯, ç³»ç»Ÿèµ„æºå·²ç»è¢«é‡Šæ”¾.

```python
# for each handler, we have 2 stream directions:
#    upstream:    from client to server direction
#                 read local and write to remote
#    downstream:  from server to client direction
#                 read remote and write to local

STREAM_UP = 0 #   00000000
STREAM_DOWN = 1 # 00000001
```

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, æˆ‘ä»¬æœ‰ 2 ä¸ªæ•°æ®æµæ–¹å‘

* upstream: ä» æµè§ˆå™¨ åˆ° server æ–¹å‘ â†’, è¯»å– æµè§ˆå™¨ å‘è¿‡æ¥çš„æ•°æ®, å†™å‘ server ç«¯
* downstream: ä» server åˆ° æµè§ˆå™¨ æ–¹å‘ â†, è¯»å– server å‘è¿‡æ¥çš„æ•°æ®, å†™å‘ æµè§ˆå™¨ ç«¯

Notes: **è¯·æŸ¥çœ‹ä¸Šé¢çš„å›¾æ¥ç†è§£è¿™ä¸¤ä¸ªæ•°æ®æµæ–¹å‘**

```python
# for each stream, it's waiting for reading, or writing, or both
WAIT_STATUS_INIT = 0 # 00000000
WAIT_STATUS_READING = 1  # 00000001
WAIT_STATUS_WRITING = 2 # 00000010
WAIT_STATUS_READWRITING = WAIT_STATUS_READING | WAIT_STATUS_WRITING # 00000011
```

**å¯¹äºæ¯ä¸€ä¸ªæ•°æ®æµ, å®ƒè¦ä¹ˆæ˜¯åœ¨ç­‰å¾…è¯», ç­‰å¾…å†™, æˆ–è€…æ˜¯åŒæ—¶åœ¨ç­‰å¾…è¯»å’Œå†™**

ä¸Šé¢çš„è¿™ä¸€å¥è¯è¿·æƒ‘äº†æˆ‘ç†è§£ local ç«¯çš„é€šè®¯çš„æ•´ä¸ªæµç¨‹, å…ˆè¡Œè§£é‡Šä¸€ä¸‹:

1. upstream
    * upstream ç­‰å¾…è¯», æ˜¯ç­‰å¾…ä» local socket è¯»å–æ•°æ®
    * upstream ç­‰å¾…å†™, æ˜¯ç­‰å¾…å‘ remote socket å†™å…¥æ•°æ®
    * upstream ç­‰å¾…è¯»å†™, æ˜¯ç­‰å¾…ä» local socket è¯»å–æ•°æ®, ä¹Ÿç­‰å¾…å‘ remote socket å†™å…¥æ•°æ®

1. downstream
    * downstream ç­‰å¾…è¯», æ˜¯ç­‰å¾…ä» remote socket è¯»å–æ•°æ®
    * downstream ç­‰å¾…å†™, æ˜¯ç­‰å¾…å‘ local socket å†™å…¥æ•°æ®
    * downstream ç­‰å¾…è¯»å†™, æ˜¯ç­‰å¾…ä» remote socket è¯»å–æ•°æ®, ä¹Ÿç­‰å¾…å‘ local socket å†™å…¥æ•°æ®

```python
BUF_SIZE = 32 * 1024 # ç¼“å†²åŒºå¤§å°
UP_STREAM_BUF_SIZE = 16 * 1024
DOWN_STREAM_BUF_SIZE = 32 * 1024
```

BUF_SIZE: ç¼“å†²åŒºå¤§å°, æš‚æ—¶æ²¡æœ‰åœ°æ–¹ç”¨åˆ°è¯¥å¸¸é‡

UP\_STREAM\_BUF\_SIZE: ä» upstream è¯»å–çš„æ•°æ®(ä¹Ÿå°±æ˜¯ä» local socket è¯»å–æ•°æ®)ä¸Šé™

DOWN\_STREAM\_BUF\_SIZE: ä» downstream è¯»å–çš„æ•°æ®(ä¹Ÿå°±æ˜¯ä» remote socket è¯»å–æ•°æ®)ä¸Šé™

```python
# helper exceptions for TCPRelayHandler
class BadSocksHeader(Exception):
    pass
class NoAcceptableMethods(Exception):
    pass
```

è¾…åŠ©ç±», åœ¨è§£æ socks5 åè®®çš„æ—¶å€™å‡ºé”™ä¼šæŠ›å‡ºæ¥

TCPRelayHandler
---------------

```python
class TCPRelayHandler(object):
    ...
```

TCPRelay
--------

```python
class TCPRelay(object):
    ...
```

åˆ›é€ ä¸€ä¸ª TCP æœåŠ¡å™¨, è´Ÿè´£ç›‘å¬ç«¯å£, TCP è¯·æ±‚æ¥äº†, eventloop äº§ç”Ÿäº‹ä»¶, ä¼ é€’åˆ°è¿™é‡Œ, æ˜¯æœåŠ¡å™¨ socket å‘ç”Ÿçš„äº‹ä»¶? è¯´æ˜ æµè§ˆå™¨ è¯·æ±‚è¿æ¥. ä¸æ˜¯? è¯´æ˜æ˜¯ä¸€ä¸ªå·²ç»è¢«æ¥å—çš„è¯·æ±‚å‘ç”Ÿäº†ä¸å¯æè¿°.

### \_\_init\_\_

```python
def __init__(self, config, dns_resolver, is_local, stat_callback=None):
    self._config = config
    self._is_local = is_local
    self._dns_resolver = dns_resolver
    self._closed = False
    self._eventloop = None
    self._fd_to_handlers = {} # file descriptor(å…¨å±€å”¯ä¸€çš„ä¸€ä¸ªé•¿æ•´æ•°L) => ç›¸å¯¹åº”çš„å¤„ç†å™¨
    self._is_tunnel = False

    self._timeout = config['timeout']
    self._timeouts = []  # a list for all the handlers
    # we trim the timeouts once a while
    self._timeout_offset = 0   # last checked position for timeout
    self._handler_to_timeouts = {}  # key: handler value: index in timeouts ä¸ºäº†é«˜æ•ˆåˆ é™¤ list é‡Œçš„å…ƒç´ 

    if is_local:
        listen_addr = config['local_address']
        listen_port = config['local_port']
    else:
        listen_addr = config['server']
        listen_port = config['server_port']
    self._listen_port = listen_port

    addrs = socket.getaddrinfo(listen_addr, listen_port, 0,
                                socket.SOCK_STREAM, socket.SOL_TCP) # socket.SOCK_STREAM æŒ‡å®šä¸º tcp
    if len(addrs) == 0:
        raise Exception("can't get addrinfo for %s:%d" %
                        (listen_addr, listen_port))
    af, socktype, proto, canonname, sa = addrs[
        0]  # family(AF_INET) type(socket.SOCK_STREAM) protocol(IPPROTOTCP) æƒå¨å›å¤ (address, port)
    server_socket = socket.socket(af, socktype, proto)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(sa)
    server_socket.setblocking(False)
    if config['fast_open']:
        try:
            server_socket.setsockopt(socket.SOL_TCP, 23, 5)
        except socket.error:
            logging.error('warning: fast open is not available')
            self._config['fast_open'] = False
    server_socket.listen(1024)
    self._server_socket = server_socket
    self._stat_callback = stat_callback
```

å‚æ•°:

* config: é…ç½®æ–‡ä»¶, éœ€è¦ç”¨åˆ°é‡Œé¢çš„ `local_address`, `local_port`ç­‰
* dns_resolver: dns æŸ¥è¯¢å™¨, ç”¨æ¥æŸ¥è¯¢ server çš„ipåœ°å€
* is_local: æ˜¯ä¸æ˜¯ local ç«¯, ä¸è¿‡æˆ‘ä»¬åªç«™åœ¨ local ç«¯, æ­¤å‚æ•°å¯ä»¥å¿½ç•¥
* stat_callback: æ•°æ®ç»Ÿè®¡å‡½æ•°, ç”¨æ¥ç»Ÿè®¡æµé‡çš„å‡½æ•°, é»˜è®¤ä¸º`None`

```python
self._config = config
self._is_local = is_local
self._dns_resolver = dns_resolver
```

å°†å‚æ•°å­˜åˆ° `self` é‡Œé¢

```python
self._closed = False
```

æ ‡è¯†è¯¥ TCP æœåŠ¡å™¨æ˜¯ä¸æ˜¯å·²ç»è¢«å…³é—­

```python
self._eventloop = None
```

è¯¥ TCP æœåŠ¡å™¨æ‰€å¤„çš„ äº‹ä»¶å¾ªç¯å™¨, åˆå§‹åŒ–ä¸º `None`

```python
self._fd_to_handlers = {}
```

æ–‡ä»¶æè¿°ç¬¦å¯¹åº”å…¶å¤„ç†å™¨(TCPRelayHandler), å›¾å½¢æè¿°ä¸€ä¸‹:

```shell
eventloop äº‹ä»¶å‘ç”Ÿ ----> å‘ç°æ˜¯æ–‡ä»¶æè¿°ç¬¦`xx`å‘ç”Ÿçš„äº‹ä»¶, æ‰¾å‡ºå¯¹åº”çš„å¤„ç†å™¨(e.g. TCPRelay), è°ƒç”¨ handle_event
                            |
               |------------|handle_event
               |            |
               |           \ /
               |        è¿™æ˜¯ä¸€ä¸ªè¯·æ±‚è¿æ¥æˆ‘ä»¬ç›‘å¬çš„ç«¯å£çš„è¯·æ±‚ Â¬
               |        accept, ç„¶åå°†ç”Ÿæˆçš„å¤„ç†è¯¥è¯·æ±‚çš„ socket ä¼ é€’ç»™ TCPRelayHandler Â¬
               |        __init__, åˆ›å»º TCPRelayHandler å®ä¾‹, ä¼šå°†å¤„ç†è¯¥è¯·æ±‚çš„ socket çš„æ–‡ä»¶ Â¬
               |       æè¿°ç¬¦ä½œä¸º key, self ä½œä¸º value, å­˜æ”¾åœ¨ _fd_to_handlers ä¸­
              \ /
              ä¸æ˜¯è¯·æ±‚è¿æ¥æˆ‘ä»¬ç›‘å¬çš„ç«¯å£çš„è¯·æ±‚, è¯´æ˜è¿™æ˜¯ä¸€ä¸ªå·²ç»æ­£åœ¨å¤„ç†ä¸­çš„ socket å‘ç”Ÿçš„äº‹ä»¶ Â¬
              ä» _fd_to_handlers å–å‡ºæ¥å®ƒå¯¹åº”çš„ TCPRelayHandler å®ä¾‹, è°ƒç”¨å…¶ handler_event å¤„ç†
```

è¿™å°±æ˜¯ `_fd_to_handlers` å¯¹è±¡çš„ä½œç”¨, å˜é‡åä¹Ÿå¯ä»¥æœ›æ–‡ç”Ÿä¹‰, fd(file descriptor) å¯¹åº” handler(TCPRelayHandlerå®ä¾‹)

```python
self._is_tunnel = False
```

TODO: æ²¡æ‡‚æš‚ä¸è§£é‡Š

```python
self._timeout = config['timeout']
```

ä»é…ç½®æ–‡ä»¶å–å‡ºæ¥ `timeout` å­—æ®µ, å­˜ä¸‹æ¥. è¶…æ—¶æ—¶é—´, è¿‡äº†è¿™ä¸ªè¶…æ—¶æ—¶é—´, å³ä¾¿è¯·æ±‚æ²¡æœ‰å¤„ç†å®Œæ¯•, ä¹Ÿè¦é”€æ¯.

```python
self._timeouts = []  # a list for all the handlers
```

è¿™é‡Œé¢å­˜æ”¾äº†æ‰€æœ‰çš„ handler, ä»å˜é‡åå­—ä¸Šæ¥çœ‹, å‡è®¾æ‰€æœ‰çš„éƒ½å·²ç»è¿‡æœŸ, ç„¶åå¤„ç†çš„æ—¶å€™åˆ¤æ–­æ˜¯ä¸æ˜¯çœŸçš„è¿‡æœŸäº†.

```python
self._timeout_offset = 0   # last checked position for timeout
```

åœ¨ `timeouts` é‡Œé¢æœ€åä¸€æ¬¡æ£€æŸ¥çš„ä½ç½®.

```python
self._handler_to_timeouts = {}
```

key: handler value: index in timeouts key æ˜¯ TCPRelayHandler çš„ hash å€¼, value ä¸ºå…¶åœ¨ `timeouts` ä¸­çš„ç´¢å¼•å€¼, è¯¥å˜é‡æ˜¯ä¸ºäº†é«˜æ•ˆåˆ é™¤ `timeouts` é‡Œçš„å…ƒç´ .

```python
listen_addr = config['local_address']
listen_port = config['local_port']
```

ä»é…ç½®æ–‡ä»¶é‡Œé¢å–å‡ºæ¥éœ€è¦ç›‘å¬çš„æœ¬åœ°IPåœ°å€(æ³¨æ„, è¿™é‡Œä¸èƒ½å¡«å†™åŸŸå)å’Œç«¯å£å·.

```python
self._listen_port = listen_port
```

å­˜ä¸‹æ¥éœ€è¦ç›‘å¬çš„ç«¯å£å·

```python
addrs = socket.getaddrinfo(listen_addr, listen_port, 0,
                                   socket.SOCK_STREAM, socket.SOL_TCP) # socket.SOCK_STREAM æŒ‡å®šä¸º tcp
```

è¿™é‡Œçš„ `getaddrinfo` æ˜¯æ¥è·å–ç›‘å¬è¿™ä¸ª IP åœ°å€å’Œç«¯å£å·éœ€è¦çš„æ‰€æœ‰ä¿¡æ¯, æœ‰äº†è¿™äº›ä¿¡æ¯, æˆ‘ä»¬æ‰èƒ½ç›‘å¬é…ç½®çš„ç«¯å£å·, è¯¥æ–¹æ³•ç”± `socket` æ¨¡å—æä¾›, å…¶å®å°±æ˜¯å°è£…äº†ä¸€ä»½ C é‡Œé¢çš„æ–¹æ³•, åé¢å¯ä»¥è¯¦ç»†çš„ä»‹ç» C é‡Œé¢çš„ socket, å’Œ python å®˜æ–¹è§£é‡Šå™¨ `cpython` æ˜¯å¦‚ä½•å°è£…çš„, è¿™é‡Œæˆ‘ä»¬çŸ¥é“å°±å°±å¥½.

```python
if len(addrs) == 0:
            raise Exception("can't get addrinfo for %s:%d" %
                            (listen_addr, listen_port))
```

å¦‚æœ `addr` çš„ `len` ä¸º 0 è¯´æ˜è·å–è¯¥IPåœ°å€çš„æ—¶å€™å‡ºé”™, æ— æ³•è¿›è¡Œä¸‹ä¸€æ­¥çš„è¡Œä¸º, æŠ›å‡ºé”™è¯¯.

```python
af, socktype, proto, canonname, sa = addrs[
            0]  # family(AF_INET) type(socket.SOCK_STREAM) protocol(IPPROTOTCP) æƒå¨å›å¤ (address, port)
```

af: address family åœ°å€å®¶åº­

type: type

prototocal

canonname: æƒå¨å›å¤

sa: socket address åŒ…å«ç›‘å¬è¯¥åœ°å€çš„æ‰€æœ‰ä¿¡æ¯

```python
server_socket = socket.socket(af, socktype, proto)
```

åˆ›å»º socket å¯¹è±¡, ä¼ å…¥åœ¨ä¸Šæ–¹æ‹¿åˆ°çš„ä¿¡æ¯.

```python
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
```

è®¾ç½® socket é€‰é¡¹.

```python
server_socket.bind(sa)
```

ç»‘å®šåœ°å€, éœ€è¦ä¸€ä¸ªå…ƒç»„ `(address, port)`

```python
server_socket.setblocking(False)
```

éé˜»å¡å¼ç›‘å¬

```python
server_socket.listen(1024)
```

å¼€å§‹ç›‘å¬, ä¼ å…¥æœ€å¤§çš„ç›‘å¬é˜Ÿåˆ—æ•°é‡.

```python
self._server_socket = server_socket
``

å­˜å‚¨ä¸‹æ¥ `socket`

```python
self._stat_callback = stat_callback
```

å­˜å‚¨ä¸‹æ¥ `stat` ç»Ÿè®¡å‡½æ•°.

### add_to_loop

```python
def add_to_loop(self, loop):
    if self._eventloop:
        raise Exception('already add to loop')
    if self._closed:
        raise Exception('already closed')
    self._eventloop = loop
    self._eventloop.add(self._server_socket,
                        eventloop.POLL_IN | eventloop.POLL_ERR, self)
    self._eventloop.add_periodic(self.handle_periodic)
```

å°†è‡ªèº«åŠ å…¥å¾ªç¯å™¨, ä¼ é€’è¿‡æ¥çš„å°±æ˜¯å¾ªç¯å™¨. å¦‚æœå·²ç»åœ¨ä¸€ä¸ªå¾ªç¯å™¨ä¸­äº†, å°±æŠ›å‡ºé”™è¯¯. å¦‚æœå·²ç»è¢«å…³é—­, æŠ›å‡ºé”™è¯¯. å­˜å‚¨ä¸‹æ¥å¾ªç¯å™¨, ç„¶åå°†è‡ªèº«çš„ `_server_socket` ä¹Ÿå°±æ˜¯æœåŠ¡å™¨ socket (listen çš„ socket), ç›‘å¬æ¨¡å¼ä¸ºæœ‰é”™è¯¯äº§ç”Ÿ(POLL\_ERR)å’Œæœ‰æ•°æ®æµå…¥(POLL\_IN), ç„¶åå°†è‡ªèº«çš„å‘¨æœŸæ€§å‡½æ•°åŠ å…¥å¾ªç¯å™¨ä¸­.

### remove_handler

```python
def remove_handler(self, handler):
    index = self._handler_to_timeouts.get(hash(handler), -1) # ä»å…¨éƒ¨çš„å¤„ç†å™¨ä¸­æ‰¾åˆ°éœ€è¦ç§»é™¤çš„å¤„ç†å™¨
    if index >= 0: # å¦‚æœæ‰¾åˆ°äº†
        # delete is O(n), so we just set it to None
        self._timeouts[index] = None # å°†å…¶åœ¨_timeoutsä¸­çš„å¼•ç”¨ç½®ä¸º None é‡Šæ”¾èµ„æº
        del self._handler_to_timeouts[hash(handler)]
```

æ ¹æ® `handler` æ‹¿å‡ºæ¥è¯¥ `handler` åœ¨ `_timeouts` é‡Œé¢çš„ç´¢å¼•å€¼, è¿™é‡Œæ˜¯ä¸ºäº†é«˜æ•ˆçš„åˆ é™¤ `handler`, å› ä¸ºå¦‚æœæ²¡æœ‰è¿™ä¸ªç´¢å¼•å€¼, é‚£å°±è¦å¾ªç¯æ•´ä¸ª `_timeouts` æ•°ç»„æ¥æ‰¾åˆ°è¿™ä¸ª `handler`, é€Ÿåº¦ä¼šæ…¢! å¦‚æœæ‰¾åˆ°äº†, å°±ç½®å…¶ä¸º `None`

**æ³¨æ„**

* ç½®ä¸º `None`, è€Œä¸æ˜¯åˆ é™¤, æ˜¯ä¸ºäº†ä¸å½±å“ä¿å­˜ä¸‹æ¥çš„å…¶ä»–çš„ `handler` åœ¨ `_handler_to_timeouts` ä¸­çš„ç´¢å¼•å€¼
* `hash(handler)` å› ä¸º `_handler_to_timeouts` é‡Œé¢å­˜å‚¨çš„æ˜¯ `handler` çš„ hash å€¼

### update_activity

```python
def update_activity(self, handler, data_len): # handler: TCPReplyHandler, data_len: æ´»è·ƒçš„æ—¶å€™ä¼ é€çš„å­—èŠ‚æ•°
    if data_len and self._stat_callback: # ç”±å®ä¾‹åŒ– TCPReply æ—¶ä¼ é€’è¿›æ¥çš„å‡½æ•°, ä¸ºäº†ç»Ÿè®¡éœ€è¦, ä¸è¿‡è¯¥ç‰ˆæœ¬çš„ shadowsocks å¹¶æ²¡æœ‰ç”¨åˆ°è¯¥ç»Ÿè®¡å‡½æ•°
        self._stat_callback(self._listen_port, data_len)

    # set handler to active
    now = int(time.time())
    if now - handler.last_activity < eventloop.TIMEOUT_PRECISION:
        # thus we can lower timeout modification frequency
        return
    handler.last_activity = now # æ›´æ–° TCPReply çš„ last_activity
    index = self._handler_to_timeouts.get(hash(handler), -1) # æ ¹æ®handler çš„ ID æ‹¿å‡ºæ¥å½“æ—¶çš„ _timeouts çš„é•¿åº¦ å…¶å®å°±æ˜¯è‡ªå·±åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å€¼
    if index >= 0:
        # delete is O(n), so we just set it to None
        self._timeouts[index] = None # å› ä¸ºåœ¨å– length å€¼å¾—æ—¶å€™è‡ªå·±å¹¶ä¸åœ¨é‡Œé¢, æ‰€ä»¥åœ¨è‡ªå·±è¿›å…¥è¿™ä¸ª _timeouts çš„ list é‡Œé¢çš„æ—¶å€™ è¿™ä¸ª length å€¼å°±æ˜¯è‡ªå·±çš„ç´¢å¼•å€¼
    length = len(self._timeouts) # å½“å‰çš„æ‰€æœ‰ handler çš„æ•°é‡
    self._timeouts.append(handler) # å°†å½“å‰çš„ handler æ”¾å…¥ _timeouts ä¸­
    self._handler_to_timeouts[hash(handler)] = length # _handler_to_timeouts å­˜æ”¾çš„æ˜¯ å¤„ç†å™¨ çš„ ID å¯¹åº”ç€å¤„ç†å™¨è‡ªå·±åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å€¼
```

æ›´æ–°æ´»è·ƒ, å‚æ•°:

* handler: å¤„ç†å™¨ TCPRelayHandler
* data_len: æ•°æ®é•¿åº¦

```shell
                         |---------> æ•°æ®é•¿åº¦æœ‰æ•ˆå¹¶ä¸”ç»Ÿè®¡å‡½æ•°å­˜åœ¨, å°†ç›‘å¬çš„ç«¯å£å’Œæ•°æ®é•¿åº¦ä¼ é€’ç»™ç»Ÿè®¡å‡½æ•°
                         |
update_activity ---------|---------> æ£€æµ‹å½“å‰æ—¶é—´è·ç¦»è¿™ä¸ª handler çš„ä¸Šæ¬¡æ´»è·ƒæ˜¯å¦å·²ç»å°äºäº† eventloop çš„æ—¶é—´ç²’åº¦,
                         |           è¿™é‡Œçš„åˆ¤æ–­å¯ä»¥é™ä½æˆ‘ä»¬è¶…æ—¶ä¿®æ”¹çš„é¢‘ç‡, å¦‚æœæ²¡æœ‰è¶…è¿‡, ç›´æ¥è¿”å›
                         |
                         |---------> å¦‚æœåœ¨ _handler_to_timeouts é‡Œé¢æ‰¾åˆ°äº†å¯¹åº”çš„ç´¢å¼•å€¼, è¯´æ˜è¯¥ handler å·²ç»è¢«
                         |           å­˜å‚¨ä¸‹æ¥, å°†å…¶å¯¹åº”çš„ä½ç½®ç½®ä¸º None
                         |
                         |--------- è·å–å½“å‰çš„æ‰€æœ‰çš„ handler çš„é•¿åº¦, ç„¶åå°†å…¶å­˜å‚¨åˆ°å­˜æ”¾æ‰€æœ‰çš„ handler çš„æ•°ç»„ _timeouts ä¸­,
                         |          ç„¶åå°†è¯¥ handler åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å­˜å‚¨ä¸‹æ¥.


```

[Wikipedia-socks5-zh]: <https://zh.wikipedia.org/wiki/SOCKS>
[Wikipedia-socks5-en]: <https://en.wikipedia.org/wiki/SOCKS>
[TCPçŠ¶æ€æœº]: <https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm>
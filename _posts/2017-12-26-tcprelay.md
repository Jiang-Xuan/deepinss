---
title: tcprelay ğŸ’Œ
---
Introduce to TCPRelay
=====================

EventLoop äº‹ä»¶å‘ç”Ÿäº†, éœ€è¦å¤„ç†å™¨è¿›è¡Œå¤„ç†, åœ¨è¿™é‡Œå¤„ç† TCP çš„æµç¨‹. åœ¨ `local.py` é‡Œé¢æœ‰è¿™ä¹ˆä¸€è¡Œä»£ç  `tcp_server = tcprelay.TCPRelay(config, dns_resolver, True)`, åˆ›å»º TCP çš„æœåŠ¡å™¨. è¿˜æœ‰è¿™ä¹ˆä¸€è¡Œ `tcp_server.add_to_loop(loop)`, å°†å…¶æ·»åŠ è¿›å…¥äº‹ä»¶è½®è®­å™¨, å‘ç”Ÿäº‹ä»¶çš„æ—¶å€™, è°ƒç”¨è¿™é‡Œçš„æ–¹æ³•æ¥å¤„ç† TCP è¯·æ±‚.

TL;DR
------

<!-- TODO: add TL;DR -->

æœ¯è¯­è§„å®š
-------

* æµè§ˆå™¨: socks5 çš„å®¢æˆ·ç«¯
* local: Shadowsocks çš„ local ç«¯
* server: Shadowsocks çš„ server ç«¯
* æœåŠ¡å™¨: è¯·æ±‚çš„æœåŠ¡ç«¯(e.g. google.comæœåŠ¡)
* local socket: ä»£è¡¨ local ç«¯åˆ›å»ºçš„ç”¨æ¥å’Œ æµè§ˆå™¨ é€šè®¯çš„ socket
* remote socket: ä»£è¡¨ local ç«¯åˆ›å»ºçš„ç”¨æ¥å’Œ server é€šè®¯çš„ socket

Notes: **è®°ä½, æˆ‘ä»¬è®¨è®ºçš„æ˜¯ local ç«¯çš„ä»£ç , æ‰€ä»¥æˆ‘ä»¬çš„æ•°æ®æ˜¯è¿™æ ·æµåŠ¨çš„**, ä¸æ¶‰åŠ æœåŠ¡å™¨.

```shell

            |--------------->|                   |------------>|                 |\
æµè§ˆå™¨ ------|                |---- local ç«¯ ------|            | ---- server ç«¯---|\ è¿™è¾¹å’ŒæœåŠ¡å™¨é€šè®¯
            |<---------------|                   |<------------|                 |\

```

å¯¼å…¥æ¨¡å—
-------

```python

from __future__ import absolute_import, division, print_function, \
    with_statement

import time
import socket
import errno
import struct
import logging
import traceback
import random

from shadowsocks import cryptor, eventloop, shell, common
from shadowsocks.common import parse_header, onetimeauth_verify, \
    onetimeauth_gen, ONETIMEAUTH_BYTES, ONETIMEAUTH_CHUNK_BYTES, \
    ONETIMEAUTH_CHUNK_DATA_LEN, ADDRTYPE_AUTH

```

å¼•å…¥å†…ç½®æ¨¡å—, è¿™é‡Œå°¤å…¶è¦æ³¨æ„ `struct` æ¨¡å—, åˆæ˜¯å’Œ C æ‰“äº¤é“çš„ ğŸ‘€ æ¨¡å—. ä» `shadowsocks` æ¨¡å—å¼•å…¥ `crypto` åŠ å¯†æ¨¡å—, å¯¼å…¥ `eventloop` æ¨¡å—, ä¸»è¦æ˜¯ç”¨åˆ°é‡Œé¢çš„ä¸€äº›å¸¸é‡(POLL\_IN, POLL\_OUT, etc.)

æ¨¡å—å¸¸é‡å®šä¹‰
----------

```python

# we clear at most TIMEOUTS_CLEAN_SIZE timeouts each time
TIMEOUTS_CLEAN_SIZE = 512

```

ä¸€æ¬¡æœ€å¤šæ¸…é™¤çš„è¿‡æœŸ socket çš„æ•°é‡, å¦‚æœè¶…æ—¶çš„ socket è¶…è¿‡äº†è¿™ä¸ªä¸´ç•Œç‚¹, åˆ™åªå¤„ç† 512 ä¸ª, å‰©ä½™ç­‰å¾…ä¸‹æ¬¡å¤„ç†, ä¸»è¦æ˜¯ä¸ºäº†èƒ½åŠæ—¶å¤„ç†å‘ç”Ÿçš„äº‹ä»¶, ä¸è‡³äºåœ¨è¶…æ—¶è¯·æ±‚è¿‡å¤šçš„æ—¶å€™å¯¼è‡´åç»­äº‹ä»¶çš„å¤„ç†è¢«å»¶è¿Ÿ.

```python

MSG_FASTOPEN = 0x20000000

```

<!-- TODO: æš‚æ—¶ä¸çŸ¥è¯¥å¸¸é‡çš„ä½œç”¨ -->

```python

# SOCKS METHOD definition
METHOD_NOAUTH = 0

# SOCKS command definition # è¿™é‡Œçš„å˜é‡æ˜¯ç”± socks åè®®è§„å®šçš„åè®®å¤´çš„å¸¸é‡
CMD_CONNECT = 1
CMD_BIND = 2
CMD_UDP_ASSOCIATE = 3

```

SOCKS5 åè®®è§„å®šçš„è®¤è¯æ–¹æ³•å’Œè¿æ¥è¡Œä¸ºçš„å¸¸é‡å€¼, å¯ä»¥çœ‹çœ‹ [Wikipedia-socks5][Wikipedia-socks5-zh] å…³äº SOCKS5 æ¡æ‰‹åè®®çš„è¯¦ç»†ä»‹ç».

[è‹±æ–‡ç‰ˆä»‹ç»][Wikipedia-socks5-en], ä¸­æ–‡ç‰ˆçš„ Wikipedia æ­£å¸¸æ˜¯æ— æ³•è®¿é—®çš„.

```python

# for each opening port, we have a TCP Relay

# for each connection, we have a TCP Relay Handler to handle the connection

# for each handler, we have 2 sockets:
#    local:   connected to the client
#    remote:  connected to remote server

# for each handler, it could be at one of several stages:

# as sslocal:
# stage 0 auth METHOD received from local, reply with selection message
# stage 1 addr received from local, query DNS for remote
# stage 2 UDP assoc
# stage 3 DNS resolved, connect to remote
# stage 4 still connecting, more data from local received
# stage 5 remote connected, piping local and remote

# as ssserver:
# stage 0 just jump to stage 1
# stage 1 addr received from local, query DNS for remote
# stage 3 DNS resolved, connect to remote
# stage 4 still connecting, more data from local received
# stage 5 remote connected, piping local and remote

STAGE_INIT = 0
STAGE_ADDR = 1
STAGE_UDP_ASSOC = 2
STAGE_DNS = 3
STAGE_CONNECTING = 4
STAGE_STREAM = 5
STAGE_DESTROYED = -1

```

å¯¹äºæ¯ä¸€ä¸ªç›‘å¬çš„ç«¯å£, éƒ½ä¼šæœ‰ä¸€ä¸ª TCPrelay, å¯¹äºæ¯ä¸€æ¬¡è¿æ¥, éƒ½æœ‰ TCPRelayHandler æ¥å¤„ç†è¿™ä¸ªè¯·æ±‚.

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, æˆ‘ä»¬æœ‰ä¸¤ä¸ª socket:

1. local: è¿æ¥ client ç«¯
1. remote: è¿æ¥ server æœåŠ¡å™¨

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, å®ƒå¿…é¡»å¤„åœ¨è¿™äº›çŠ¶æ€ä¹‹ä¸€(è¿™å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœº, å¦‚æœä½ è¯»è¿‡ TCP çš„åŸç†, ä¼šå‘ç° TCP è¿æ¥ä¹Ÿæ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„çŠ¶æ€æœº, æœ‰å…´è¶£å¯ä»¥çœ‹ä¸‹IBMçš„å®˜æ–¹æ–‡æ¡£, éå¸¸æ£’, åœ¨[è¿™é‡Œ][TCPçŠ¶æ€æœº]):

sslocal çŠ¶æ€:

1. stage 0 æ”¶åˆ° æµè§ˆå™¨ å‘è¿‡æ¥çš„è®¤è¯ METHOD, ç„¶åå›å¤ç»™ æµè§ˆå™¨ é€‰æ‹©çš„ä¿¡æ¯
1. stage 1 æ”¶åˆ° local å‘è¿‡æ¥çš„ addr(è¯·æ±‚åœ°å€), å¼€å§‹æŸ¥è¯¢ server(ä¹Ÿå°±æ˜¯è¯´åœ¨é…ç½®æ–‡ä»¶é‡Œé¢ä½ å¯ä»¥å¡«å†™ssserverçš„åŸŸå, è€Œä¸ä»…ä»…å¡«å†™ IP åœ°å€) çš„ DNSä¿¡æ¯
1. stage 3 DNS æŸ¥è¯¢æˆåŠŸ, å¼€å§‹è¿æ¥ server
1. stage 4 ä»åœ¨å’Œ server è¿æ¥ä¸­, å¯ä»¥ä» æµè§ˆå™¨ è·å–æ›´å¤šä¿¡æ¯äº†, ç­‰ server ä¸€æ—¦è¿æ¥æˆåŠŸ, å°±å°†è¿™äº›æ•°æ®ä¸€èµ·å‘ç»™ server
1. stage 5 server è¿æ¥å»ºç«‹æˆåŠŸ, piping æµè§ˆå™¨ å’Œ server

`STAGE_DESTORED` è¯´æ˜è¯·æ±‚å·²ç»è¢«é”€æ¯, ç³»ç»Ÿèµ„æºå·²ç»è¢«é‡Šæ”¾.

```python

# for each handler, we have 2 stream directions:
#    upstream:    from client to server direction
#                 read local and write to remote
#    downstream:  from server to client direction
#                 read remote and write to local

STREAM_UP = 0 #   00000000
STREAM_DOWN = 1 # 00000001

```

å¯¹äºæ¯ä¸€ä¸ª TCPRelayHandler, æˆ‘ä»¬æœ‰ 2 ä¸ªæ•°æ®æµæ–¹å‘

* upstream: ä» æµè§ˆå™¨ åˆ° server æ–¹å‘ â†’, è¯»å– æµè§ˆå™¨ å‘è¿‡æ¥çš„æ•°æ®, å†™å‘ server ç«¯
* downstream: ä» server åˆ° æµè§ˆå™¨ æ–¹å‘ â†, è¯»å– server å‘è¿‡æ¥çš„æ•°æ®, å†™å‘ æµè§ˆå™¨ ç«¯

Notes: **è¯·æŸ¥çœ‹ä¸Šé¢çš„å›¾æ¥ç†è§£è¿™ä¸¤ä¸ªæ•°æ®æµæ–¹å‘**

```python

# for each stream, it's waiting for reading, or writing, or both
WAIT_STATUS_INIT = 0 # 00000000
WAIT_STATUS_READING = 1  # 00000001
WAIT_STATUS_WRITING = 2 # 00000010
WAIT_STATUS_READWRITING = WAIT_STATUS_READING | WAIT_STATUS_WRITING # 00000011

```

**å¯¹äºæ¯ä¸€ä¸ªæ•°æ®æµ, å®ƒè¦ä¹ˆæ˜¯åœ¨ç­‰å¾…è¯», ç­‰å¾…å†™, æˆ–è€…æ˜¯åŒæ—¶åœ¨ç­‰å¾…è¯»å’Œå†™**

ä¸Šé¢çš„è¿™ä¸€å¥è¯è¿·æƒ‘äº†æˆ‘ç†è§£ local ç«¯çš„é€šè®¯çš„æ•´ä¸ªæµç¨‹, å…ˆè¡Œè§£é‡Šä¸€ä¸‹:

1. upstream
    * upstream ç­‰å¾…è¯», æ˜¯ç­‰å¾…ä» local socket è¯»å–æ•°æ®
    * upstream ç­‰å¾…å†™, æ˜¯ç­‰å¾…å‘ remote socket å†™å…¥æ•°æ®
    * upstream ç­‰å¾…è¯»å†™, æ˜¯ç­‰å¾…ä» local socket è¯»å–æ•°æ®, ä¹Ÿç­‰å¾…å‘ remote socket å†™å…¥æ•°æ®

1. downstream
    * downstream ç­‰å¾…è¯», æ˜¯ç­‰å¾…ä» remote socket è¯»å–æ•°æ®
    * downstream ç­‰å¾…å†™, æ˜¯ç­‰å¾…å‘ local socket å†™å…¥æ•°æ®
    * downstream ç­‰å¾…è¯»å†™, æ˜¯ç­‰å¾…ä» remote socket è¯»å–æ•°æ®, ä¹Ÿç­‰å¾…å‘ local socket å†™å…¥æ•°æ®

```python

BUF_SIZE = 32 * 1024 # ç¼“å†²åŒºå¤§å°
UP_STREAM_BUF_SIZE = 16 * 1024
DOWN_STREAM_BUF_SIZE = 32 * 1024

```

BUF_SIZE: ç¼“å†²åŒºå¤§å°, æš‚æ—¶æ²¡æœ‰åœ°æ–¹ç”¨åˆ°è¯¥å¸¸é‡

UP\_STREAM\_BUF\_SIZE: ä» upstream è¯»å–çš„æ•°æ®(ä¹Ÿå°±æ˜¯ä» local socket è¯»å–æ•°æ®)ä¸Šé™

DOWN\_STREAM\_BUF\_SIZE: ä» downstream è¯»å–çš„æ•°æ®(ä¹Ÿå°±æ˜¯ä» remote socket è¯»å–æ•°æ®)ä¸Šé™

```python

# helper exceptions for TCPRelayHandler
class BadSocksHeader(Exception):
    pass
class NoAcceptableMethods(Exception):
    pass

```

è¾…åŠ©ç±», åœ¨è§£æ socks5 åè®®çš„æ—¶å€™å‡ºé”™ä¼šæŠ›å‡ºæ¥

TCPRelayHandler
---------------

```python

class TCPRelayHandler(object):
    ...

```

TCPRelay
--------

```python

class TCPRelay(object):
    ...

```

åˆ›é€ ä¸€ä¸ª TCP æœåŠ¡å™¨, è´Ÿè´£ç›‘å¬ç«¯å£, TCP è¯·æ±‚æ¥äº†, eventloop äº§ç”Ÿäº‹ä»¶, ä¼ é€’åˆ°è¿™é‡Œ, æ˜¯æœåŠ¡å™¨ socket å‘ç”Ÿçš„äº‹ä»¶? è¯´æ˜ æµè§ˆå™¨ è¯·æ±‚è¿æ¥. ä¸æ˜¯? è¯´æ˜æ˜¯ä¸€ä¸ªå·²ç»è¢«æ¥å—çš„è¯·æ±‚å‘ç”Ÿäº†ä¸å¯æè¿°.

### \_\_init\_\_

```python

def __init__(self, config, dns_resolver, is_local, stat_callback=None):
    self._config = config
    self._is_local = is_local
    self._dns_resolver = dns_resolver
    self._closed = False
    self._eventloop = None
    self._fd_to_handlers = {} # file descriptor(å…¨å±€å”¯ä¸€çš„ä¸€ä¸ªé•¿æ•´æ•°L) => ç›¸å¯¹åº”çš„å¤„ç†å™¨
    self._is_tunnel = False

    self._timeout = config['timeout']
    self._timeouts = []  # a list for all the handlers
    # we trim the timeouts once a while
    self._timeout_offset = 0   # last checked position for timeout
    self._handler_to_timeouts = {}  # key: handler value: index in timeouts ä¸ºäº†é«˜æ•ˆåˆ é™¤ list é‡Œçš„å…ƒç´ 

    if is_local:
        listen_addr = config['local_address']
        listen_port = config['local_port']
    else:
        listen_addr = config['server']
        listen_port = config['server_port']
    self._listen_port = listen_port

    addrs = socket.getaddrinfo(listen_addr, listen_port, 0,
                                socket.SOCK_STREAM, socket.SOL_TCP) # socket.SOCK_STREAM æŒ‡å®šä¸º tcp
    if len(addrs) == 0:
        raise Exception("can't get addrinfo for %s:%d" %
                        (listen_addr, listen_port))
    af, socktype, proto, canonname, sa = addrs[0]  # family(AF_INET) type(socket.SOCK_STREAM) protocol(IPPROTOTCP) æƒå¨å›å¤ (address, port)
    server_socket = socket.socket(af, socktype, proto)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(sa)
    server_socket.setblocking(False)
    if config['fast_open']:
        try:
            server_socket.setsockopt(socket.SOL_TCP, 23, 5)
        except socket.error:
            logging.error('warning: fast open is not available')
            self._config['fast_open'] = False
    server_socket.listen(1024)
    self._server_socket = server_socket
    self._stat_callback = stat_callback

```

å‚æ•°:

* config: é…ç½®æ–‡ä»¶, éœ€è¦ç”¨åˆ°é‡Œé¢çš„ `local_address`, `local_port`ç­‰
* dns_resolver: dns æŸ¥è¯¢å™¨, ç”¨æ¥æŸ¥è¯¢ server çš„ipåœ°å€
* is_local: æ˜¯ä¸æ˜¯ local ç«¯, ä¸è¿‡æˆ‘ä»¬åªç«™åœ¨ local ç«¯, æ­¤å‚æ•°å¯ä»¥å¿½ç•¥
* stat_callback: æ•°æ®ç»Ÿè®¡å‡½æ•°, ç”¨æ¥ç»Ÿè®¡æµé‡çš„å‡½æ•°, é»˜è®¤ä¸º`None`

```python

self._config = config
self._is_local = is_local
self._dns_resolver = dns_resolver

```

å°†å‚æ•°å­˜åˆ° `self` é‡Œé¢

```python

self._closed = False

```

æ ‡è¯†è¯¥ TCP æœåŠ¡å™¨æ˜¯ä¸æ˜¯å·²ç»è¢«å…³é—­

```python

self._eventloop = None

```

è¯¥ TCP æœåŠ¡å™¨æ‰€å¤„çš„ äº‹ä»¶å¾ªç¯å™¨, åˆå§‹åŒ–ä¸º `None`

```python

self._fd_to_handlers = {}

```

æ–‡ä»¶æè¿°ç¬¦å¯¹åº”å…¶å¤„ç†å™¨(TCPRelayHandler), å›¾å½¢æè¿°ä¸€ä¸‹:

```shell

eventloop äº‹ä»¶å‘ç”Ÿ ----> å‘ç°æ˜¯æ–‡ä»¶æè¿°ç¬¦`xx`å‘ç”Ÿçš„äº‹ä»¶, æ‰¾å‡ºå¯¹åº”çš„å¤„ç†å™¨(e.g. TCPRelay), è°ƒç”¨ handle_event
                            |
               |------------|handle_event
               |            |
               |           \ /
               |        è¿™æ˜¯ä¸€ä¸ªè¯·æ±‚è¿æ¥æˆ‘ä»¬ç›‘å¬çš„ç«¯å£çš„è¯·æ±‚ Â¬
               |        accept, ç„¶åå°†ç”Ÿæˆçš„å¤„ç†è¯¥è¯·æ±‚çš„ socket ä¼ é€’ç»™ TCPRelayHandler Â¬
               |        __init__, åˆ›å»º TCPRelayHandler å®ä¾‹, ä¼šå°†å¤„ç†è¯¥è¯·æ±‚çš„ socket çš„æ–‡ä»¶ Â¬
               |       æè¿°ç¬¦ä½œä¸º key, self ä½œä¸º value, å­˜æ”¾åœ¨ _fd_to_handlers ä¸­
              \ /
              ä¸æ˜¯è¯·æ±‚è¿æ¥æˆ‘ä»¬ç›‘å¬çš„ç«¯å£çš„è¯·æ±‚, è¯´æ˜è¿™æ˜¯ä¸€ä¸ªå·²ç»æ­£åœ¨å¤„ç†ä¸­çš„ socket å‘ç”Ÿçš„äº‹ä»¶ Â¬
              ä» _fd_to_handlers å–å‡ºæ¥å®ƒå¯¹åº”çš„ TCPRelayHandler å®ä¾‹, è°ƒç”¨å…¶ handler_event å¤„ç†

```

è¿™å°±æ˜¯ `_fd_to_handlers` å¯¹è±¡çš„ä½œç”¨, å˜é‡åä¹Ÿå¯ä»¥æœ›æ–‡ç”Ÿä¹‰, fd(file descriptor) å¯¹åº” handler(TCPRelayHandlerå®ä¾‹)

```python

self._is_tunnel = False

```

TODO: æ²¡æ‡‚æš‚ä¸è§£é‡Š

```python

self._timeout = config['timeout']

```

ä»é…ç½®æ–‡ä»¶å–å‡ºæ¥ `timeout` å­—æ®µ, å­˜ä¸‹æ¥. è¶…æ—¶æ—¶é—´, è¿‡äº†è¿™ä¸ªè¶…æ—¶æ—¶é—´, å³ä¾¿è¯·æ±‚æ²¡æœ‰å¤„ç†å®Œæ¯•, ä¹Ÿè¦é”€æ¯.

```python

self._timeouts = []  # a list for all the handlers

```

è¿™é‡Œé¢å­˜æ”¾äº†æ‰€æœ‰çš„ handler, ä»å˜é‡åå­—ä¸Šæ¥çœ‹, å‡è®¾æ‰€æœ‰çš„éƒ½å·²ç»è¿‡æœŸ, ç„¶åå¤„ç†çš„æ—¶å€™åˆ¤æ–­æ˜¯ä¸æ˜¯çœŸçš„è¿‡æœŸäº†.

```python

self._timeout_offset = 0   # last checked position for timeout

```

åœ¨ `timeouts` é‡Œé¢æœ€åä¸€æ¬¡æ£€æŸ¥çš„ä½ç½®.

```python

self._handler_to_timeouts = {}

```

key: handler value: index in timeouts key æ˜¯ TCPRelayHandler çš„ hash å€¼, value ä¸ºå…¶åœ¨ `timeouts` ä¸­çš„ç´¢å¼•å€¼, è¯¥å˜é‡æ˜¯ä¸ºäº†é«˜æ•ˆåˆ é™¤ `timeouts` é‡Œçš„å…ƒç´ .

```python

listen_addr = config['local_address']
listen_port = config['local_port']

```

ä»é…ç½®æ–‡ä»¶é‡Œé¢å–å‡ºæ¥éœ€è¦ç›‘å¬çš„æœ¬åœ°IPåœ°å€(æ³¨æ„, è¿™é‡Œä¸èƒ½å¡«å†™åŸŸå)å’Œç«¯å£å·.

```python

self._listen_port = listen_port

```

å­˜ä¸‹æ¥éœ€è¦ç›‘å¬çš„ç«¯å£å·

```python

addrs = socket.getaddrinfo(listen_addr, listen_port, 0,
                                   socket.SOCK_STREAM, socket.SOL_TCP) # socket.SOCK_STREAM æŒ‡å®šä¸º tcp

```

è¿™é‡Œçš„ `getaddrinfo` æ˜¯æ¥è·å–ç›‘å¬è¿™ä¸ª IP åœ°å€å’Œç«¯å£å·éœ€è¦çš„æ‰€æœ‰ä¿¡æ¯, æœ‰äº†è¿™äº›ä¿¡æ¯, æˆ‘ä»¬æ‰èƒ½ç›‘å¬é…ç½®çš„ç«¯å£å·, è¯¥æ–¹æ³•ç”± `socket` æ¨¡å—æä¾›, å…¶å®å°±æ˜¯å°è£…äº†ä¸€ä»½ C é‡Œé¢çš„æ–¹æ³•, åé¢å¯ä»¥è¯¦ç»†çš„ä»‹ç» C é‡Œé¢çš„ socket, å’Œ python å®˜æ–¹è§£é‡Šå™¨ `cpython` æ˜¯å¦‚ä½•å°è£…çš„, è¿™é‡Œæˆ‘ä»¬çŸ¥é“å°±å°±å¥½.

```python

if len(addrs) == 0:
            raise Exception("can't get addrinfo for %s:%d" %
                            (listen_addr, listen_port))

```

å¦‚æœ `addr` çš„ `len` ä¸º 0 è¯´æ˜è·å–è¯¥IPåœ°å€çš„æ—¶å€™å‡ºé”™, æ— æ³•è¿›è¡Œä¸‹ä¸€æ­¥çš„è¡Œä¸º, æŠ›å‡ºé”™è¯¯.

```python

af, socktype, proto, canonname, sa = addrs[0]  # family(AF_INET) type(socket.SOCK_STREAM) protocol(IPPROTOTCP) æƒå¨å›å¤ (address, port)

```

af: address family åœ°å€å®¶åº­

type: type

prototocal

canonname: æƒå¨å›å¤

sa: socket address åŒ…å«ç›‘å¬è¯¥åœ°å€çš„æ‰€æœ‰ä¿¡æ¯

```python

server_socket = socket.socket(af, socktype, proto)

```

åˆ›å»º socket å¯¹è±¡, ä¼ å…¥åœ¨ä¸Šæ–¹æ‹¿åˆ°çš„ä¿¡æ¯.

```python

server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

```

è®¾ç½® socket é€‰é¡¹.

```python

server_socket.bind(sa)

```

ç»‘å®šåœ°å€, éœ€è¦ä¸€ä¸ªå…ƒç»„ `(address, port)`

```python

server_socket.setblocking(False)

```

éé˜»å¡å¼ç›‘å¬

```python

server_socket.listen(1024)

```

å¼€å§‹ç›‘å¬, ä¼ å…¥æœ€å¤§çš„ç›‘å¬é˜Ÿåˆ—æ•°é‡.

```python

self._server_socket = server_socket

```

å­˜å‚¨ä¸‹æ¥ `socket`

```python

self._stat_callback = stat_callback

```

å­˜å‚¨ä¸‹æ¥ `stat` ç»Ÿè®¡å‡½æ•°.

### add_to_loop

```python

def add_to_loop(self, loop):
    if self._eventloop:
        raise Exception('already add to loop')
    if self._closed:
        raise Exception('already closed')
    self._eventloop = loop
    self._eventloop.add(self._server_socket,
                        eventloop.POLL_IN | eventloop.POLL_ERR, self)
    self._eventloop.add_periodic(self.handle_periodic)

```

å°†è‡ªèº«åŠ å…¥å¾ªç¯å™¨, ä¼ é€’è¿‡æ¥çš„å°±æ˜¯å¾ªç¯å™¨. å¦‚æœå·²ç»åœ¨ä¸€ä¸ªå¾ªç¯å™¨ä¸­äº†, å°±æŠ›å‡ºé”™è¯¯. å¦‚æœå·²ç»è¢«å…³é—­, æŠ›å‡ºé”™è¯¯. å­˜å‚¨ä¸‹æ¥å¾ªç¯å™¨, ç„¶åå°†è‡ªèº«çš„ `_server_socket` ä¹Ÿå°±æ˜¯æœåŠ¡å™¨ socket (listen çš„ socket), ç›‘å¬æ¨¡å¼ä¸ºæœ‰é”™è¯¯äº§ç”Ÿ(POLL\_ERR)å’Œæœ‰æ•°æ®æµå…¥(POLL\_IN), ç„¶åå°†è‡ªèº«çš„å‘¨æœŸæ€§å‡½æ•°åŠ å…¥å¾ªç¯å™¨ä¸­.

### remove_handler

```python

def remove_handler(self, handler):
    index = self._handler_to_timeouts.get(hash(handler), -1) # ä»å…¨éƒ¨çš„å¤„ç†å™¨ä¸­æ‰¾åˆ°éœ€è¦ç§»é™¤çš„å¤„ç†å™¨
    if index >= 0: # å¦‚æœæ‰¾åˆ°äº†
        # delete is O(n), so we just set it to None
        self._timeouts[index] = None # å°†å…¶åœ¨_timeoutsä¸­çš„å¼•ç”¨ç½®ä¸º None é‡Šæ”¾èµ„æº
        del self._handler_to_timeouts[hash(handler)]

```

æ ¹æ® `handler` æ‹¿å‡ºæ¥è¯¥ `handler` åœ¨ `_timeouts` é‡Œé¢çš„ç´¢å¼•å€¼, è¿™é‡Œæ˜¯ä¸ºäº†é«˜æ•ˆçš„åˆ é™¤ `handler`, å› ä¸ºå¦‚æœæ²¡æœ‰è¿™ä¸ªç´¢å¼•å€¼, é‚£å°±è¦å¾ªç¯æ•´ä¸ª `_timeouts` æ•°ç»„æ¥æ‰¾åˆ°è¿™ä¸ª `handler`, é€Ÿåº¦ä¼šæ…¢! å¦‚æœæ‰¾åˆ°äº†, å°±ç½®å…¶ä¸º `None`

**æ³¨æ„**

* ç½®ä¸º `None`, è€Œä¸æ˜¯åˆ é™¤, æ˜¯ä¸ºäº†ä¸å½±å“ä¿å­˜ä¸‹æ¥çš„å…¶ä»–çš„ `handler` åœ¨ `_handler_to_timeouts` ä¸­çš„ç´¢å¼•å€¼
* `hash(handler)` å› ä¸º `_handler_to_timeouts` é‡Œé¢å­˜å‚¨çš„æ˜¯ `handler` çš„ hash å€¼

### update_activity

```python

def update_activity(self, handler, data_len): # handler: TCPReplyHandler, data_len: æ´»è·ƒçš„æ—¶å€™ä¼ é€çš„å­—èŠ‚æ•°
    if data_len and self._stat_callback: # ç”±å®ä¾‹åŒ– TCPReply æ—¶ä¼ é€’è¿›æ¥çš„å‡½æ•°, ä¸ºäº†ç»Ÿè®¡éœ€è¦, ä¸è¿‡è¯¥ç‰ˆæœ¬çš„ shadowsocks å¹¶æ²¡æœ‰ç”¨åˆ°è¯¥ç»Ÿè®¡å‡½æ•°
        self._stat_callback(self._listen_port, data_len)

    # set handler to active
    now = int(time.time())
    if now - handler.last_activity < eventloop.TIMEOUT_PRECISION:
        # thus we can lower timeout modification frequency
        return
    handler.last_activity = now # æ›´æ–° TCPReply çš„ last_activity
    index = self._handler_to_timeouts.get(hash(handler), -1) # æ ¹æ®handler çš„ ID æ‹¿å‡ºæ¥å½“æ—¶çš„ _timeouts çš„é•¿åº¦ å…¶å®å°±æ˜¯è‡ªå·±åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å€¼
    if index >= 0:
        # delete is O(n), so we just set it to None
        self._timeouts[index] = None # å› ä¸ºåœ¨å– length å€¼å¾—æ—¶å€™è‡ªå·±å¹¶ä¸åœ¨é‡Œé¢, æ‰€ä»¥åœ¨è‡ªå·±è¿›å…¥è¿™ä¸ª _timeouts çš„ list é‡Œé¢çš„æ—¶å€™ è¿™ä¸ª length å€¼å°±æ˜¯è‡ªå·±çš„ç´¢å¼•å€¼
    length = len(self._timeouts) # å½“å‰çš„æ‰€æœ‰ handler çš„æ•°é‡
    self._timeouts.append(handler) # å°†å½“å‰çš„ handler æ”¾å…¥ _timeouts ä¸­
    self._handler_to_timeouts[hash(handler)] = length # _handler_to_timeouts å­˜æ”¾çš„æ˜¯ å¤„ç†å™¨ çš„ ID å¯¹åº”ç€å¤„ç†å™¨è‡ªå·±åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å€¼

```

æ›´æ–°æ´»è·ƒ, å‚æ•°:

* handler: å¤„ç†å™¨ TCPRelayHandler
* data_len: æ•°æ®é•¿åº¦

```shell

                   |---> æ•°æ®é•¿åº¦æœ‰æ•ˆå¹¶ä¸”ç»Ÿè®¡å‡½æ•°å­˜åœ¨, å°†ç›‘å¬çš„ç«¯å£å’Œæ•°æ®é•¿åº¦ä¼ é€’ç»™ç»Ÿè®¡å‡½æ•°
                   |
update_activity -- |---> æ£€æµ‹å½“å‰æ—¶é—´è·ç¦»è¿™ä¸ª handler çš„ä¸Šæ¬¡æ´»è·ƒæ˜¯å¦å·²ç»å°äºäº† eventloop çš„æ—¶é—´ç²’åº¦,
                   |           è¿™é‡Œçš„åˆ¤æ–­å¯ä»¥é™ä½æˆ‘ä»¬è¶…æ—¶ä¿®æ”¹çš„é¢‘ç‡, å¦‚æœæ²¡æœ‰è¶…è¿‡, ç›´æ¥è¿”å›
                   |
                   |---> å¦‚æœåœ¨ _handler_to_timeouts é‡Œé¢æ‰¾åˆ°äº†å¯¹åº”çš„ç´¢å¼•å€¼, è¯´æ˜è¯¥ handler å·²ç»è¢«
                   |           å­˜å‚¨ä¸‹æ¥, å°†å…¶å¯¹åº”çš„ä½ç½®ç½®ä¸º None
                   |
                   |--- è·å–å½“å‰çš„æ‰€æœ‰çš„ handler çš„é•¿åº¦, ç„¶åå°†å…¶å­˜å‚¨åˆ°å­˜æ”¾æ‰€æœ‰çš„ handler çš„æ•°ç»„ _timeouts ä¸­,
                   |    ç„¶åå°†è¯¥ handler åœ¨ _timeouts é‡Œé¢çš„ç´¢å¼•å­˜å‚¨ä¸‹æ¥.

```

è¯¦ç»†çš„è§£é‡Šä¸€ä¸‹ `_timeouts` å˜é‡å’Œ `_handler_to_timeouts` è¿™ä¸¤ä¸ªå˜é‡çš„å¯¹åº”å…³ç³»:

è¿™é‡Œ handler1, handler2, handler3, éƒ½æ˜¯åœ¨åˆ›å»ºçš„æ—¶å€™è¢«æ·»åŠ , ä¹Ÿå°±æ˜¯ä» `TCPRelayHandler` çš„æ„é€ å‡½æ•° `__init__` çš„ `self._update_activity()` è°ƒç”¨çš„

handler1è¢«åˆ›å»º -> handler2è¢«åˆ›å»º -> handler3è¢«åˆ›å»º

```shell

  _timeouts           _handler_to_timeouts
+-----------+        +--------------------+
|           |        |                    |
| handler1 ---------------->  0           |
|           |        |                    |
| handler2 ---------------->  1           |
|           | ------>|                    |
| handler3 ---------------->  2           |
|           |        |                    |
|   ...     |        |       ...          |
+-----------+        +--------------------|

```

åœ¨ TCPRelayHandler çš„ `_on_local_read` å’Œ `_on_remote_read` ä¸­, ä¼šè°ƒç”¨è¯¥å‡½æ•°.

handler1 è°ƒç”¨ `_on_local_read`

```shell

  _timeouts           _handler_to_timeouts
+-----------+        +--------------------+
|           |        |                    |
|  None    ---------------->  0           |
|           |        |                    |
| handler2 ---------------->  1           |
|           | ------>|                    |
| handler3 ---------------->  2           |
|           |        |                    |
| handler1 ---------------->  3           |
|   ...     |        |       ...          |
+-----------+        +--------------------|

```

handler1 è°ƒç”¨ `_on_remote_read`

```shell

  _timeouts           _handler_to_timeouts
+-----------+        +--------------------+
|           |        |                    |
|  None    ---------------->  0           |
|           |        |                    |
| handler2 ---------------->  1           |
|           | ------>|                    |
| handler3 ---------------->  2           |
|           |        |                    |
|  None    ---------------->  3           |
|           |        |                    |
| handler1 ---------------->  4           |
|   ...     |        |       ...          |
+-----------+        +--------------------|

```

handler2 è°ƒç”¨ `_on_local_read`

```shell

  _timeouts           _handler_to_timeouts
+-----------+        +--------------------+
|           |        |                    |
|  None    ---------------->  0           |
|           |        |                    |
|  None    ---------------->  1           |
|           | ------>|                    |
| handler3 ---------------->  2           |
|           |        |                    |
|  None    ---------------->  3           |
|           |        |                    |
| handler1 ---------------->  4           |
|           |        |                    |
| handler2 ---------------->  5           |
|   ...     |        |       ...          |
+-----------+        +--------------------|

```

handler2 è°ƒç”¨ `_on_remote_read`

```shell

  _timeouts           _handler_to_timeouts
+-----------+        +--------------------+
|           |        |                    |
|  None    ---------------->  0           |
|           |        |                    |
|  None    ---------------->  1           |
|           | ------>|                    |
| handler3 ---------------->  2           |
|           |        |                    |
|  None    ---------------->  3           |
|           |        |                    |
| handler1 ---------------->  4           |
|           |        |                    |
|  None    ---------------->  5           |
|           |        |                    |
| handler2 ---------------->  6           |
|   ...     |        |       ...          |
+-----------+        +--------------------|

```

ä»¥æ­¤ç±»æ¨...

æˆ‘ä»¬ä» `_handler_to_timeouts` å–å‡ºæ¥ç´¢å¼•å€¼æ¯”æˆ‘ä»¬å¾ªç¯æ•´ä¸ª `timeouts` æ¥è·å–å¯¹åº”çš„ handler é€Ÿåº¦ä¼šå¿«å¾ˆå¤š, ä½†æ˜¯ä¼šå¢åŠ ç‚¹å†…å­˜å ç”¨, æ¯•ç«Ÿå¤šäº†ä¸€ä¸ªå˜é‡.

### \_sweep\_timeout

```python
def _sweep_timeout(self):
    # tornado's timeout memory management is more flexible than we need
    # we just need a sorted last_activity queue and it's faster than heapq
    # in fact we can do O(1) (å¤§ã€‡è¡¨ç¤ºæ³•, ç®—æ³•å¤æ‚åº¦) insertion/remove so we invent(å‘æ˜, åˆ›é€ ) our own
    if self._timeouts:
        logging.log(shell.VERBOSE_LEVEL, 'sweeping timeouts')
        now = time.time()
        length = len(self._timeouts)
        pos = self._timeout_offset
        while pos < length:
            handler = self._timeouts[pos]
            if handler:
                if now - handler.last_activity < self._timeout:
                    break
                else:
                    if handler.remote_address:
                        logging.warn('timed out: %s:%d' %
                                        handler.remote_address)
                    else:
                        logging.warn('timed out')
                    handler.destroy()
                    self._timeouts[pos] = None
                    pos += 1
            else:
                pos += 1
        if pos > TIMEOUTS_CLEAN_SIZE and pos > length >> 1:
            # clean up the timeout queue when it gets larger than half
            # of the queue
            self._timeouts = self._timeouts[pos:]
            for key in self._handler_to_timeouts:
                self._handler_to_timeouts[key] -= pos
            pos = 0
        self._timeout_offset = pos

```

æ¸…é™¤è¶…æ—¶çš„ handler(TCPRelayHandler)

æ³¨é‡Šç¿»è¯‘:

> tornado çš„è¶…æ—¶å†…å­˜ç®¡ç†æ¯”æˆ‘ä»¬éœ€è¦çš„æ›´å…·å¼¹æ€§
> æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªæ ¹æ® last_activity æ’åºçš„é˜Ÿåˆ—, å¹¶ä¸”æ¯” headq(å †æ’åºç®—æ³•) æ›´å¿«
> å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥åš O(1) æ’å…¥/ç§»é™¤, å› æ­¤æˆ‘ä»¬åˆ›é€ è‡ªå·±çš„ç®—æ³•

tornado æ˜¯ä¸€ä¸ª Python ç‰ˆæœ¬çš„ Web Server, å®˜ç½‘åœ¨[è¿™é‡Œ][tornado]

```python
if self._timeouts:
```

å¦‚æœ `self._timeouts` æ•°ç»„ä¸ä¸ºç©º, å¼€å§‹å¤„ç†

```python
now = time.time()
length = len(self._timeouts)
pos = self._timeout_offset
```

* è·å–å½“å‰æ—¶é—´æˆ³
* è·å–å½“å‰çš„ _timeouts æ•°ç»„é•¿åº¦
* è·å–ä¸Šä¸€æ¬¡åœ¨è¿™é‡Œå¤„ç†çš„åç§»é‡, åˆå§‹åŒ–ä¸º0ï¸âƒ£

```python
while pos < length:
```

å¦‚æœä¸Šæ¬¡å¤„ç†çš„åœ°æ–¹å°äºäº† `_timeouts` çš„é•¿åº¦, è¯´æ˜æœ‰æ–°çš„ handler è¢«æ·»åŠ è¿›æ¥, éœ€è¦åœ¨è¿™ä¸€æ¬¡çš„ `_sweep_timeout` å¤„ç†.

```python
handler = self._timeouts[pos]
```

å–å‡ºä¸Šæ¬¡å¤„ç†çš„ä¸‹ä¸€ä¸ª handler, `if handler:`, å¦‚æœ handler ä¸å­˜åœ¨, `else: pos += 1`, `pos` å˜é‡åŠ ä¸€.

å¦‚æœ handler å­˜åœ¨, èµ°å‘é”€æ¯æµç¨‹:

```python

if now - handler.last_activity < self._timeout: # config ä¸­é…ç½®çš„è¿‡æœŸæ—¶é—´, å¦‚æœè¶…è¿‡æ­¤äº‹ä»¶, å³ä¾¿è¯¥è¯·æ±‚æ²¡æœ‰å¤„ç†å®Œä¹Ÿè¦ destroy é‡Šæ”¾èµ„æº
    break

```

ä¸€æ—¦å‘ç°æ´»è·ƒçš„ `handler` æ²¡æœ‰è¶…æ—¶, `break` æ‰, ä¸å†å¤„ç† timeout, ä¸ºäº†èƒ½å¿«é€Ÿå“åº”è¯·æ±‚.

```python
if handler.remote_address:
        logging.warn('timed out: %s:%d' %
                        handler.remote_address)
    else:
        logging.info('timed out')
        logging.warn('timed out')
    handler.destroy()
    self._timeouts[pos] = None  # free memory # å…¶å®åœ¨ destroy çš„æ—¶å€™å°±å·²ç»è¢«ç½®ä¸ºäº†ç©º, è¿™é‡Œæ˜¯å¤šæ­¤ä¸€ä¸¾, ä¸è¿‡ä¹Ÿå¯ä»¥è¯´æ˜¯ä¸ºäº†ä¿è¯çš„ç¡®å·²ç»è¢«é‡Šæ”¾
    pos += 1
```

å‘ç°è¯¥ handler å·²ç»è¶…æ—¶, è°ƒç”¨ handler çš„ destory é”€æ¯, ç„¶åå°† `_timeouts` çš„ pos ä½ç½® ç½®ä¸º `None`. ç„¶å `pos += 1`.

```python
if pos > TIMEOUTS_CLEAN_SIZE and pos > length >> 1:
```

å¦‚æœ pos å¤§äºäº† `TIMEOUTS_CLEAN_SIZE` å¸¸é‡, è¯´æ˜è¶…æ—¶çš„å·²ç»å¾ˆå¤šäº†, åœ¨ä¸Šé¢çš„ destory ä¸­å¯ä»¥çœ‹åˆ°, å¹¶æ²¡æœ‰åˆ é™¤åœ¨ `_timeouts` ä¸­çš„ä½ç½®, è€Œæ˜¯ç½®ä¸ºäº† `None`, æ‰€ä»¥å¦‚æœè¶…æ—¶è¿‡å¤šä¼šå¯¼è‡´ `_timeouts` ä¸­å…ƒç´ è¿‡å¤š, å¹¶ä¸”éƒ½æ˜¯ `None`, æ‰€ä»¥è¦åœ¨è¿™é‡Œå¤„ç†ä¸€ä¸‹, è¿™é‡Œè¿˜æœ‰ä¸€ä¸ª `and` ç¬¦å·, ç¬¬äºŒä¸ªåˆ¤æ–­æ˜¯ `pos > length >> 1` è¯´æ˜ pos çš„å€¼æ˜¯ä¸æ˜¯è¶…è¿‡äº† `_timeouts` çš„é•¿åº¦çš„ä¸€åŠ, è¿™é‡Œæ˜¯ä½è¿ç®—ç¬¦ **>>**.

ä½è¿ç®—ç¬¦å¯¹äºå¥‡å¶æ•°çš„å¤„ç†ä¸å°½ç›¸åŒ, *å¦‚æœlengthæ˜¯å¶æ•°åˆ™æ˜¯ä¸€åŠ, å¥‡æ•°åˆ™æ˜¯ä¸€åŠå‡ä¸€*

ä½è¿ç®—:

```javascript
/* å¶æ•° */
const foo = 4
foo >> 1
// 4 / 2 result: 2

/* å¥‡æ•° */
const bar = 7
bar >> 1
// 7 / 2 - 1 result: 3
```

```python
self._timeouts = self._timeouts[pos:]
```

ç§»é™¤ None å€¼

```python
for key in self._handler_to_timeouts:
    self._handler_to_timeouts[key] -= pos
```

æ¯ä¸€ä¸ªå¤„ç†å™¨å­˜ç€è‡ªå·±è¢«updateå½“æ—¶çš„å¤„ç†å™¨çš„æ•°é‡, è¿™é‡Œç§»é™¤äº† None ä¹Ÿè¦å°†æ‰€æœ‰çš„å¤„ç†å™¨ å¯¹åº”çš„ å‡å»è¿™äº›è¢«åˆ é™¤çš„ None å€¼çš„æ•°é‡

```python
pos = 0
```

é‡ç½® pos å€¼ä¸º0

```python
self._timeout_offset = pos
```

æ›´æ–° TCPReply ä¸Šçš„å˜é‡, æ¥ä¸ºä¸‹ä¸€æ¬¡åˆ°è¿™é‡Œç”¨åˆ°. åˆ†æ®µå¼å¤„ç†æ€ç»´.

### handle_event

```python
 def handle_event(self, sock, fd, event):
    if sock:
        logging.log(shell.VERBOSE_LEVEL, 'fd %d %s', fd,
                    eventloop.EVENT_NAMES.get(event, event))
    if sock == self._server_socket:
        if event & eventloop.POLL_ERR:
            # TODO
            raise Exception('server_socket error')
        try:
            logging.debug('accept')
            conn = self._server_socket.accept()
            TCPRelayHandler(self, self._fd_to_handlers,
                            self._eventloop, conn[0], self._config,
                            self._dns_resolver, self._is_local)
        except (OSError, IOError) as e:
            error_no = eventloop.errno_from_exception(e)
            if error_no in (errno.EAGAIN, errno.EINPROGRESS,
                            errno.EWOULDBLOCK):
                return
            else:
                shell.print_exception(e)
                if self._config['verbose']:
                    traceback.print_exc()
    else: # å‘ç”Ÿäº‹ä»¶çš„ socket æ˜¯ä¸€ä¸ªéæœåŠ¡ç«¯ socket, è¿™æ˜¯å¤„ç† socks5 å®¢æˆ·ç«¯è¯·æ±‚çš„ä¸€ä¸ª socket
        if sock:
            handler = self._fd_to_handlers.get(fd, None)
            if handler:
                handler.handle_event(sock, event)
        else:
            logging.warn('poll removed fd')
```

æœ€é‡è¦çš„æ–¹æ³•, TCP è¯·æ±‚éƒ½ä¼šä¼ é€’åˆ°è¿™é‡Œ, å¹¶ä¸”ä¼ å…¥å‚æ•°:

* sock: å‘ç”Ÿ tcp äº‹ä»¶çš„ socket
* fd: å‘ç”Ÿ tcp äº‹ä»¶çš„ æ–‡ä»¶æè¿°ç¬¦, å°±æ˜¯ä¸€ä¸ª float æ•°å­—
* event: å‘ç”Ÿ tcp äº‹ä»¶çš„ç±»å‹, æ˜¯å¯è¯»äº‹ä»¶å‘ç”Ÿè¿˜æ˜¯å¯å†™äº‹ä»¶å‘ç”Ÿå¼‚æˆ–é”™è¯¯äº‹ä»¶å‘ç”Ÿ

å¦‚æœ sock å­˜åœ¨, æ‰“å°è¯·æ±‚çš„ `fd` ä»¥åŠå‘ç”Ÿçš„äº‹ä»¶æ¨¡å¼

ç„¶ååˆ¤æ–­å‘ç”Ÿäº‹ä»¶çš„æ˜¯ä¸æ˜¯æˆ‘ä»¬çš„æœåŠ¡å™¨ socket, å¦‚æœæ˜¯æœåŠ¡å™¨çš„ socket å‘ç”Ÿäº†äº‹ä»¶, è¯´æ˜è¿™æ˜¯æœ‰è¯·æ±‚æµå…¥, æˆ‘ä»¬èµ°å‘æœåŠ¡å™¨æµç¨‹.

ä¸‹é¢æ˜¯å¤„ç†çš„ä»£ç :

```python
if sock == self._server_socket: # å¦‚æœå‘ç”Ÿäº‹ä»¶çš„ socket æ˜¯æˆ‘ä»¬ç›‘å¬çš„ socket
    if event & eventloop.POLL_ERR:
        # TODO
        raise Exception('server_socket error')
    try:
        logging.debug('accept')
        conn = self._server_socket.accept() # socks5 æœåŠ¡ç«¯çš„ socket æ¥å—è¿æ¥, å°†ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ socket æ¥å¤„ç†å®¢æˆ·ç«¯çš„è¯·æ±‚ conn[0]æ˜¯æ–°åˆ›å»ºçš„è¿™ä¸ª socket conn[1]æ˜¯è¿æ¥è¿‡æ¥çš„å®¢æˆ·ç«¯çš„ipå’Œport example: ('127.0.0.1', 9999)
        TCPRelayHandler(self, self._fd_to_handlers, # è¿™é‡Œå°† _fd_to_handlers ä¼ é€’ç»™ TCPRelayHandler, ä»–ä¼šå°†è¯·æ±‚çš„ socket æ˜ å°„åˆ°è¿™ä¸ª dict é‡Œé¢
                        self._eventloop, conn[0], self._config,
                        self._dns_resolver, self._is_local)
    except (OSError, IOError) as e:
        error_no = eventloop.errno_from_exception(e)
        if error_no in (errno.EAGAIN, errno.EINPROGRESS,
                        errno.EWOULDBLOCK):
            return
        else:
            shell.print_exception(e)
            if self._config['verbose']:
                traceback.print_exc()
```

å›¾å½¢åŒ–æµç¨‹

```shell
                          |------> å¦‚æœ event æ˜¯ POLL_ERR, è¯´æ˜æˆ‘ä»¬ç›‘å¬çš„ socket å‡ºç°äº†é”™è¯¯, æ— æ³•ç»§ç»­, æŠ›å‡ºæ¥é”™è¯¯âŒ
                          |
is server socket ---------|----|--> try æ¥å—å®¢æˆ·ç«¯çš„è¿æ¥è¯·æ±‚, å¹¶åˆ›å»ºå’Œè¯¥è¯·æ±‚ç›¸å…³çš„ TCPRelayHandler
                               |
                               |--> except æ¥å—è¯·æ±‚çš„æ—¶å€™å‘ç”Ÿäº†é”™è¯¯
```

å¦‚æœå‘ç”Ÿäº‹ä»¶çš„ä¸æ˜¯ server socket, è¯´æ˜è¿™æ˜¯ä¸€ä¸ªå·²æœ‰çš„è¯·æ±‚å‘ç”Ÿçš„äº‹ä»¶

```python
else: # å‘ç”Ÿäº‹ä»¶çš„ socket æ˜¯ä¸€ä¸ªéæœåŠ¡ç«¯ socket, è¿™æ˜¯å¤„ç† socks5 å®¢æˆ·ç«¯è¯·æ±‚çš„ä¸€ä¸ª socket
    if sock:
        handler = self._fd_to_handlers.get(fd, None)
        if handler:
            handler.handle_event(sock, event)
    else:
        logging.warn('poll removed fd')
```

å›¾å½¢åŒ–æµç¨‹:

```python
                          |-----> å¦‚æœå‘ç”Ÿäº‹ä»¶çš„ socket å­˜åœ¨, æ ¹æ®æ–‡ä»¶æè¿°ç¬¦å–å‡ºæ¥å’Œè¯¥è¯·æ±‚ç›¸å…³çš„ TCPRelayHandler
                          |             |
not server socket --------|             |-----> å¦‚æœhandlerå­˜åœ¨, è°ƒç”¨å…¶ handler_event å¹¶ä¸”ä¼ å…¥ socket å’Œ äº‹ä»¶æ¨¡å¼
                          |
                          |-----> å¦‚æœå‘ç”Ÿäº‹ä»¶çš„ socket ä¸å­˜åœ¨, è¯´æ˜ poll å·²ç»ç§»é™¤äº†è¯¥æ–‡ä»¶æè¿°ç¬¦çš„ç›‘å¬

```

<!-- 
\_timeouts | \_timeout\_offset
---------- | -----------------
0          | 0
1          | 0 -->

[Wikipedia-socks5-zh]: <https://zh.wikipedia.org/wiki/SOCKS>
[Wikipedia-socks5-en]: <https://en.wikipedia.org/wiki/SOCKS>
[TCPçŠ¶æ€æœº]: <https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm>
[tornado]: <http://www.tornadoweb.org/en/stable/>